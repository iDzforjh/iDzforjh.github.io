{"meta":{"title":"Fraser Porter Bridges","subtitle":"坐而言，不如起而行","description":"JIT, 2018, Network engineering Undergraduate student","author":"Fraser·Porter·Bridges·'iDzforjh'·Bu","url":"https://idzforjh.github.io","root":"https://idzforjh.github.io/"},"pages":[{"title":"About","date":"2020-09-16T16:00:01.000Z","updated":"2023-06-19T01:19:50.111Z","comments":true,"path":"about.html","permalink":"https://idzforjh.github.io/about.html","excerpt":"","text":"关于你好，陌生人。 很高兴能与你在这个互联网的小小角落里相识，亦或是重逢。 我JIT, 2018, Network engineering Undergraduate student. 不善于沟通，轻微的社交困难。（当然也很乐于分享自己的所见所闻。） 学习方向 Research interests：华为路由交换、协议分析、密码学、深度学习、Java全栈。 熟悉语言：Java Web, Python, C&#x2F;C++, C# 深度学习框架 Deeplearning Framework: Pytorch, Mxnet 爱好 Hobby: 指弹(Fingerstyle guitar)、竞技反曲(Archery) 已发表论文https://ieeexplore.ieee.org/document/9498867 未来 TOEFL：110 GRE：320+3 GPA：3.0 以第一作者身份发表SCI"},{"title":"文章归档","date":"2023-06-19T08:02:17.400Z","updated":"2023-06-19T08:02:17.385Z","comments":true,"path":"archive.html","permalink":"https://idzforjh.github.io/archive.html","excerpt":"","text":""},{"title":"我的朋友","date":"2023-06-19T13:22:46.072Z","updated":"2023-06-19T13:17:06.816Z","comments":true,"path":"friend.html","permalink":"https://idzforjh.github.io/friend.html","excerpt":"","text":"致偏执的Fraser真没想到我们在这样一个地方告别，但跟人告别的时候吧，还是得用力一点，因为你多说一句话，说不定就是最后一句，多看一眼，弄不好就是最后一眼。 ————《后会无期》 我的小伙伴们"},{"title":"categories","date":"2020-10-01T11:10:45.000Z","updated":"2023-06-19T02:47:14.969Z","comments":true,"path":"categories/index.html","permalink":"https://idzforjh.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Convolutional Neural Networks Step by Step","slug":"Convolution Model Step","date":"2023-06-21T01:38:41.000Z","updated":"2023-06-21T02:47:36.379Z","comments":true,"path":"2023/06/21/Convolution Model Step/","link":"","permalink":"https://idzforjh.github.io/2023/06/21/Convolution%20Model%20Step/","excerpt":"","text":"Convolutional Neural Networks: Step by StepIn this assignment, you will implement convolutional (CONV) and pooling (POOL) layers in numpy, including both forward propagation and (optionally) backward propagation. By the end of this notebook, you’ll be able to: Explain the convolution operation Apply two different types of pooling operation Identify the components used in a convolutional neural network (padding, stride, filter, …) and their purpose Build a convolutional neural network Notation: Superscript $[l]$ denotes an object of the $l^{th}$ layer. Example: $a^{[4]}$ is the $4^{th}$ layer activation. $W^{[5]}$ and $b^{[5]}$ are the $5^{th}$ layer parameters. Superscript $(i)$ denotes an object from the $i^{th}$ example. Example: $x^{(i)}$ is the $i^{th}$ training example input. Subscript $i$ denotes the $i^{th}$ entry of a vector. Example: $a^{[l]}_i$ denotes the $i^{th}$ entry of the activations in layer $l$, assuming this is a fully connected (FC) layer. $n_H$, $n_W$ and $n_C$ denote respectively the height, width and number of channels of a given layer. If you want to reference a specific layer $l$, you can also write $n_H^{[l]}$, $n_W^{[l]}$, $n_C^{[l]}$. $n_{H_{prev}}$, $n_{W_{prev}}$ and $n_{C_{prev}}$ denote respectively the height, width and number of channels of the previous layer. If referencing a specific layer $l$, this could also be denoted $n_H^{[l-1]}$, $n_W^{[l-1]}$, $n_C^{[l-1]}$. You should be familiar with numpy and&#x2F;or have completed the previous courses of the specialization. Let’s get started! Table of Contents 1 - Packages 2 - Outline of the Assignment 3 - Convolutional Neural Networks 3.1 - Zero-Padding Exercise 1 - zero_pad 3.2 - Single Step of Convolution Exercise 2 - conv_single_step 3.3 - Convolutional Neural Networks - Forward Pass Exercise 3 - conv_forward 4 - Pooling Layer 4.1 - Forward Pooling Exercise 4 - pool_forward 5 - Backpropagation in Convolutional Neural Networks (OPTIONAL &#x2F; UNGRADED) 5.1 - Convolutional Layer Backward Pass 5.1.1 - Computing dA 5.1.2 - Computing dW 5.1.3 - Computing db Exercise 5 - conv_backward 5.2 Pooling Layer - Backward Pass 5.2.1 Max Pooling - Backward Pass Exercise 6 - create_mask_from_window 5.2.2 - Average Pooling - Backward Pass Exercise 7 - distribute_value 5.2.3 Putting it Together: Pooling Backward Exercise 8 - pool_backward 1 - PackagesLet’s first import all the packages that you will need during this assignment. numpy is the fundamental package for scientific computing with Python. matplotlib is a library to plot graphs in Python. np.random.seed(1) is used to keep all the random function calls consistent. This helps to grade your work. 1234567891011121314import numpy as npimport h5pyimport matplotlib.pyplot as pltfrom public_tests import *%matplotlib inlineplt.rcParams[&#x27;figure.figsize&#x27;] = (5.0, 4.0) # set default size of plotsplt.rcParams[&#x27;image.interpolation&#x27;] = &#x27;nearest&#x27;plt.rcParams[&#x27;image.cmap&#x27;] = &#x27;gray&#x27;%load_ext autoreload%autoreload 2np.random.seed(1) 2 - Outline of the AssignmentYou will be implementing the building blocks of a convolutional neural network! Each function you will implement will have detailed instructions to walk you through the steps: Convolution functions, including: Zero Padding Convolve window Convolution forward Convolution backward (optional) Pooling functions, including: Pooling forward Create mask Distribute value Pooling backward (optional) This notebook will ask you to implement these functions from scratch in numpy. In the next notebook, you will use the TensorFlow equivalents of these functions to build the following model: Note: For every forward function, there is a corresponding backward equivalent. Hence, at every step of your forward module you will store some parameters in a cache. These parameters are used to compute gradients during backpropagation. 3 - Convolutional Neural NetworksAlthough programming frameworks make convolutions easy to use, they remain one of the hardest concepts to understand in Deep Learning. A convolution layer transforms an input volume into an output volume of different size, as shown below. In this part, you will build every step of the convolution layer. You will first implement two helper functions: one for zero padding and the other for computing the convolution function itself. 3.1 - Zero-PaddingZero-padding adds zeros around the border of an image: Figure 1 : Zero-Padding Image (3 channels, RGB) with a padding of 2. The main benefits of padding are: It allows you to use a CONV layer without necessarily shrinking the height and width of the volumes. This is important for building deeper networks, since otherwise the height&#x2F;width would shrink as you go to deeper layers. An important special case is the “same” convolution, in which the height&#x2F;width is exactly preserved after one layer. It helps us keep more of the information at the border of an image. Without padding, very few values at the next layer would be affected by pixels at the edges of an image. Exercise 1 - zero_padImplement the following function, which pads all the images of a batch of examples X with zeros. Use np.pad. Note if you want to pad the array “a” of shape $(5,5,5,5,5)$ with pad = 1 for the 2nd dimension, pad = 3 for the 4th dimension and pad = 0 for the rest, you would do: 1a = np.pad(a, ((0,0), (1,1), (0,0), (3,3), (0,0)), mode=&#x27;constant&#x27;, constant_values = (0,0)) 1234567891011121314151617181920212223# GRADED FUNCTION: zero_paddef zero_pad(X, pad): &quot;&quot;&quot; Pad with zeros all images of the dataset X. The padding is applied to the height and width of an image, as illustrated in Figure 1. Argument: X -- python numpy array of shape (m, n_H, n_W, n_C) representing a batch of m images pad -- integer, amount of padding around each image on vertical and horizontal dimensions Returns: X_pad -- padded image of shape (m, n_H + 2 * pad, n_W + 2 * pad, n_C) &quot;&quot;&quot; #(≈ 1 line) # X_pad = None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE return X_pad 1234567891011121314np.random.seed(1)x = np.random.randn(4, 3, 3, 2)x_pad = zero_pad(x, 3)print (&quot;x.shape =\\n&quot;, x.shape)print (&quot;x_pad.shape =\\n&quot;, x_pad.shape)print (&quot;x[1,1] =\\n&quot;, x[1, 1])print (&quot;x_pad[1,1] =\\n&quot;, x_pad[1, 1])fig, axarr = plt.subplots(1, 2)axarr[0].set_title(&#x27;x&#x27;)axarr[0].imshow(x[0, :, :, 0])axarr[1].set_title(&#x27;x_pad&#x27;)axarr[1].imshow(x_pad[0, :, :, 0])zero_pad_test(zero_pad) 3.2 - Single Step of ConvolutionIn this part, implement a single step of convolution, in which you apply the filter to a single position of the input. This will be used to build a convolutional unit, which: Takes an input volume Applies a filter at every position of the input Outputs another volume (usually of different size) Figure 2 : Convolution operation with a filter of 3x3 and a stride of 1 (stride &#x3D; amount you move the window each time you slide) In a computer vision application, each value in the matrix on the left corresponds to a single pixel value. You convolve a 3x3 filter with the image by multiplying its values element-wise with the original matrix, then summing them up and adding a bias. In this first step of the exercise, you will implement a single step of convolution, corresponding to applying a filter to just one of the positions to get a single real-valued output. Later in this notebook, you’ll apply this function to multiple positions of the input to implement the full convolutional operation. Exercise 2 - conv_single_stepImplement conv_single_step(). Hint document website. Note: The variable b will be passed in as a numpy array. If you add a scalar (a float or integer) to a numpy array, the result is a numpy array. In the special case of a numpy array containing a single value, you can cast it as a float to convert it to a scalar. 1234567891011121314151617181920212223242526272829# GRADED FUNCTION: conv_single_stepdef conv_single_step(a_slice_prev, W, b): &quot;&quot;&quot; Apply one filter defined by parameters W on a single slice (a_slice_prev) of the output activation of the previous layer. Arguments: a_slice_prev -- slice of input data of shape (f, f, n_C_prev) W -- Weight parameters contained in a window - matrix of shape (f, f, n_C_prev) b -- Bias parameters contained in a window - matrix of shape (1, 1, 1) Returns: Z -- a scalar value, the result of convolving the sliding window (W, b) on a slice x of the input data &quot;&quot;&quot; #(≈ 3 lines of code) # Element-wise product between a_slice_prev and W. Do not add the bias yet. # s = None # Sum over all entries of the volume s. # Z = None # Add bias b to Z. Cast b to a float() so that Z results in a scalar value. # Z = None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE return Z 1234567891011np.random.seed(1)a_slice_prev = np.random.randn(4, 4, 3)W = np.random.randn(4, 4, 3)b = np.random.randn(1, 1, 1)Z = conv_single_step(a_slice_prev, W, b)print(&quot;Z =&quot;, Z)conv_single_step_test(conv_single_step)assert (type(Z) == np.float64 or type(Z) == np.float32), &quot;You must cast the output to float&quot;assert np.isclose(Z, -6.999089450680221), &quot;Wrong value&quot; 3.3 - Convolutional Neural Networks - Forward PassIn the forward pass, you will take many filters and convolve them on the input. Each ‘convolution’ gives you a 2D matrix output. You will then stack these outputs to get a 3D volume: Exercise 3 - conv_forwardImplement the function below to convolve the filters W on an input activation A_prev.This function takes the following inputs: A_prev, the activations output by the previous layer (for a batch of m inputs); Weights are denoted by W. The filter window size is f by f. The bias vector is b, where each filter has its own (single) bias. You also have access to the hyperparameters dictionary, which contains the stride and the padding. Hint: To select a 2x2 slice at the upper left corner of a matrix “a_prev” (shape (5,5,3)), you would do: 1a_slice_prev = a_prev[0:2,0:2,:] Notice how this gives a 3D slice that has height 2, width 2, and depth 3. Depth is the number of channels.This will be useful when you will define a_slice_prev below, using the start/end indexes you will define. To define a_slice you will need to first define its corners vert_start, vert_end, horiz_start and horiz_end. This figure may be helpful for you to find out how each of the corners can be defined using h, w, f and s in the code below. Figure 3 : Definition of a slice using vertical and horizontal start&#x2F;end (with a 2x2 filter) This figure shows only a single channel. Reminder:The formulas relating the output shape of the convolution to the input shape are: $$n_H &#x3D; \\Bigl\\lfloor \\frac{n_{H_{prev}} - f + 2 \\times pad}{stride} \\Bigr\\rfloor +1$$ $$n_W &#x3D; \\Bigl\\lfloor \\frac{n_{W_{prev}} - f + 2 \\times pad}{stride} \\Bigr\\rfloor +1$$ $$n_C &#x3D; \\text{number of filters used in the convolution}$$ For this exercise, don’t worry about vectorization! Just implement everything with for-loops. Additional Hints (if you’re stuck): Use array slicing (e.g.varname[0:1,:,3:5]) for the following variables:a_prev_pad ,W, b Copy the starter code of the function and run it outside of the defined function, in separate cells. Check that the subset of each array is the size and dimension that you’re expecting. To decide how to get the vert_start, vert_end, horiz_start, horiz_end, remember that these are indices of the previous layer. Draw an example of a previous padded layer (8 x 8, for instance), and the current (output layer) (2 x 2, for instance). The output layer’s indices are denoted by h and w. Make sure that a_slice_prev has a height, width and depth. Remember that a_prev_pad is a subset of A_prev_pad. Think about which one should be used within the for loops. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# GRADED FUNCTION: conv_forwarddef conv_forward(A_prev, W, b, hparameters): &quot;&quot;&quot; Implements the forward propagation for a convolution function Arguments: A_prev -- output activations of the previous layer, numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev) W -- Weights, numpy array of shape (f, f, n_C_prev, n_C) b -- Biases, numpy array of shape (1, 1, 1, n_C) hparameters -- python dictionary containing &quot;stride&quot; and &quot;pad&quot; Returns: Z -- conv output, numpy array of shape (m, n_H, n_W, n_C) cache -- cache of values needed for the conv_backward() function &quot;&quot;&quot; # Retrieve dimensions from A_prev&#x27;s shape (≈1 line) # (m, n_H_prev, n_W_prev, n_C_prev) = None # Retrieve dimensions from W&#x27;s shape (≈1 line) # (f, f, n_C_prev, n_C) = None # Retrieve information from &quot;hparameters&quot; (≈2 lines) # stride = None # pad = None # Compute the dimensions of the CONV output volume using the formula given above. # Hint: use int() to apply the &#x27;floor&#x27; operation. (≈2 lines) # n_H = None # n_W = None # Initialize the output volume Z with zeros. (≈1 line) # Z = None # Create A_prev_pad by padding A_prev # A_prev_pad = None # for i in range(None): # loop over the batch of training examples # a_prev_pad = None # Select ith training example&#x27;s padded activation # for h in range(None): # loop over vertical axis of the output volume # Find the vertical start and end of the current &quot;slice&quot; (≈2 lines) # vert_start = None # vert_end = None # for w in range(None): # loop over horizontal axis of the output volume # Find the horizontal start and end of the current &quot;slice&quot; (≈2 lines) # horiz_start = None # horiz_end = None # for c in range(None): # loop over channels (= #filters) of the output volume # Use the corners to define the (3D) slice of a_prev_pad (See Hint above the cell). (≈1 line) # a_slice_prev = None # Convolve the (3D) slice with the correct filter W and bias b, to get back one output neuron. (≈3 line) # weights = None # biases = None # Z[i, h, w, c] = None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE # Save information in &quot;cache&quot; for the backprop cache = (A_prev, W, b, hparameters) return Z, cache 1234567891011121314np.random.seed(1)A_prev = np.random.randn(2, 5, 7, 4)W = np.random.randn(3, 3, 4, 8)b = np.random.randn(1, 1, 1, 8)hparameters = &#123;&quot;pad&quot; : 1, &quot;stride&quot;: 2&#125;Z, cache_conv = conv_forward(A_prev, W, b, hparameters)print(&quot;Z&#x27;s mean =\\n&quot;, np.mean(Z))print(&quot;Z[0,2,1] =\\n&quot;, Z[0, 2, 1])print(&quot;cache_conv[0][1][2][3] =\\n&quot;, cache_conv[0][1][2][3])conv_forward_test(conv_forward) Finally, a CONV layer should also contain an activation, in which case you would add the following line of code: 1234# Convolve the window to get back one output neuronZ[i, h, w, c] = ...# Apply activationA[i, h, w, c] = activation(Z[i, h, w, c]) You don’t need to do it here, however. 4 - Pooling LayerThe pooling (POOL) layer reduces the height and width of the input. It helps reduce computation, as well as helps make feature detectors more invariant to its position in the input. The two types of pooling layers are: Max-pooling layer: slides an ($f, f$) window over the input and stores the max value of the window in the output. Average-pooling layer: slides an ($f, f$) window over the input and stores the average value of the window in the output. These pooling layers have no parameters for backpropagation to train. However, they have hyperparameters such as the window size $f$. This specifies the height and width of the $f \\times f$ window you would compute a max or average over. 4.1 - Forward PoolingNow, you are going to implement MAX-POOL and AVG-POOL, in the same function. Exercise 4 - pool_forwardImplement the forward pass of the pooling layer. Follow the hints in the comments below. Reminder:As there’s no padding, the formulas binding the output shape of the pooling to the input shape is: ​ $$n_H &#x3D; \\Bigl\\lfloor \\frac{n_{H_{prev}} - f}{stride} \\Bigr\\rfloor +1$$ ​ $$n_W &#x3D; \\Bigl\\lfloor \\frac{n_{W_{prev}} - f}{stride} \\Bigr\\rfloor +1$$ ​ $$n_C &#x3D; n_{C_{prev}}$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# GRADED FUNCTION: pool_forwarddef pool_forward(A_prev, hparameters, mode = &quot;max&quot;): &quot;&quot;&quot; Implements the forward pass of the pooling layer Arguments: A_prev -- Input data, numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev) hparameters -- python dictionary containing &quot;f&quot; and &quot;stride&quot; mode -- the pooling mode you would like to use, defined as a string (&quot;max&quot; or &quot;average&quot;) Returns: A -- output of the pool layer, a numpy array of shape (m, n_H, n_W, n_C) cache -- cache used in the backward pass of the pooling layer, contains the input and hparameters &quot;&quot;&quot; # Retrieve dimensions from the input shape (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape # Retrieve hyperparameters from &quot;hparameters&quot; f = hparameters[&quot;f&quot;] stride = hparameters[&quot;stride&quot;] # Define the dimensions of the output n_H = int(1 + (n_H_prev - f) / stride) n_W = int(1 + (n_W_prev - f) / stride) n_C = n_C_prev # Initialize output matrix A A = np.zeros((m, n_H, n_W, n_C)) # for i in range(None): # loop over the training examples # for h in range(None): # loop on the vertical axis of the output volume # Find the vertical start and end of the current &quot;slice&quot; (≈2 lines) # vert_start = None # vert_end = None # for w in range(None): # loop on the horizontal axis of the output volume # Find the vertical start and end of the current &quot;slice&quot; (≈2 lines) # horiz_start = None # horiz_end = None # for c in range (None): # loop over the channels of the output volume # Use the corners to define the current slice on the ith training example of A_prev, channel c. (≈1 line) # a_prev_slice = None # Compute the pooling operation on the slice. # Use an if statement to differentiate the modes. # Use np.max and np.mean. # if mode == &quot;max&quot;: # A[i, h, w, c] = None # elif mode == &quot;average&quot;: # A[i, h, w, c] = None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE # Store the input and hparameters in &quot;cache&quot; for pool_backward() cache = (A_prev, hparameters) # Making sure your output shape is correct #assert(A.shape == (m, n_H, n_W, n_C)) return A, cache 123456789101112131415# Case 1: stride of 1np.random.seed(1)A_prev = np.random.randn(2, 5, 5, 3)hparameters = &#123;&quot;stride&quot; : 1, &quot;f&quot;: 3&#125;A, cache = pool_forward(A_prev, hparameters, mode = &quot;max&quot;)print(&quot;mode = max&quot;)print(&quot;A.shape = &quot; + str(A.shape))print(&quot;A[1, 1] =\\n&quot;, A[1, 1])A, cache = pool_forward(A_prev, hparameters, mode = &quot;average&quot;)print(&quot;mode = average&quot;)print(&quot;A.shape = &quot; + str(A.shape))print(&quot;A[1, 1] =\\n&quot;, A[1, 1])pool_forward_test(pool_forward) Expected output 12345678910111213mode = maxA.shape = (2, 3, 3, 3)A[1, 1] = [[1.96710175 0.84616065 1.27375593] [1.96710175 0.84616065 1.23616403] [1.62765075 1.12141771 1.2245077 ]]mode = averageA.shape = (2, 3, 3, 3)A[1, 1] = [[ 0.44497696 -0.00261695 -0.31040307] [ 0.50811474 -0.23493734 -0.23961183] [ 0.11872677 0.17255229 -0.22112197]] 123456789101112131415# Case 2: stride of 2np.random.seed(1)A_prev = np.random.randn(2, 5, 5, 3)hparameters = &#123;&quot;stride&quot; : 2, &quot;f&quot;: 3&#125;A, cache = pool_forward(A_prev, hparameters)print(&quot;mode = max&quot;)print(&quot;A.shape = &quot; + str(A.shape))print(&quot;A[0] =\\n&quot;, A[0])print()A, cache = pool_forward(A_prev, hparameters, mode = &quot;average&quot;)print(&quot;mode = average&quot;)print(&quot;A.shape = &quot; + str(A.shape))print(&quot;A[1] =\\n&quot;, A[1]) Expected Output: 12345678910111213141516171819mode = maxA.shape = (2, 2, 2, 3)A[0] = [[[1.74481176 0.90159072 1.65980218] [1.74481176 1.6924546 1.65980218]] [[1.13162939 1.51981682 2.18557541] [1.13162939 1.6924546 2.18557541]]]mode = averageA.shape = (2, 2, 2, 3)A[1] = [[[-0.17313416 0.32377198 -0.34317572] [ 0.02030094 0.14141479 -0.01231585]] [[ 0.42944926 0.08446996 -0.27290905] [ 0.15077452 0.28911175 0.00123239]]] **What you should remember**: A convolution extracts features from an input image by taking the dot product between the input data and a 3D array of weights (the filter). The 2D output of the convolution is called the feature map A convolution layer is where the filter slides over the image and computes the dot product This transforms the input volume into an output volume of different size Zero padding helps keep more information at the image borders, and is helpful for building deeper networks, because you can build a CONV layer without shrinking the height and width of the volumes Pooling layers gradually reduce the height and width of the input by sliding a 2D window over each specified region, then summarizing the features in that region Congratulations! You have now implemented the forward passes of all the layers of a convolutional network. Great work! The remainder of this notebook is optional, and will not be graded. If you carry on, just remember to hit the Submit button to submit your work for grading first. 5 - Backpropagation in Convolutional Neural Networks (OPTIONAL &#x2F; UNGRADED)In modern deep learning frameworks, you only have to implement the forward pass, and the framework takes care of the backward pass, so most deep learning engineers don’t need to bother with the details of the backward pass. The backward pass for convolutional networks is complicated. If you wish, you can work through this optional portion of the notebook to get a sense of what backprop in a convolutional network looks like. When in an earlier course you implemented a simple (fully connected) neural network, you used backpropagation to compute the derivatives with respect to the cost to update the parameters. Similarly, in convolutional neural networks you can calculate the derivatives with respect to the cost in order to update the parameters. The backprop equations are not trivial and were not derived in lecture, but are briefly presented below. 5.1 - Convolutional Layer Backward PassLet’s start by implementing the backward pass for a CONV layer. 5.1.1 - Computing dA:This is the formula for computing $dA$ with respect to the cost for a certain filter $W_c$ and a given training example: $$dA \\mathrel{+}&#x3D; \\sum {h&#x3D;0} ^{n_H} \\sum{w&#x3D;0} ^{n_W} W_c \\times dZ_{hw} \\tag{1}$$ Where $W_c$ is a filter and $dZ_{hw}$ is a scalar corresponding to the gradient of the cost with respect to the output of the conv layer Z at the hth row and wth column (corresponding to the dot product taken at the ith stride left and jth stride down). Note that at each time, you multiply the the same filter $W_c$ by a different dZ when updating dA. We do so mainly because when computing the forward propagation, each filter is dotted and summed by a different a_slice. Therefore when computing the backprop for dA, you are just adding the gradients of all the a_slices. In code, inside the appropriate for-loops, this formula translates into: 1da_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :] += W[:,:,:,c] * dZ[i, h, w, c] 5.1.2 - Computing dW:This is the formula for computing $dW_c$ ($dW_c$ is the derivative of one filter) with respect to the loss: $$dW_c \\mathrel{+}&#x3D; \\sum {h&#x3D;0} ^{n_H} \\sum{w&#x3D;0} ^ {n_W} a_{slice} \\times dZ_{hw} \\tag{2}$$ Where $a_{slice}$ corresponds to the slice which was used to generate the activation $Z_{ij}$. Hence, this ends up giving us the gradient for $W$ with respect to that slice. Since it is the same $W$, we will just add up all such gradients to get $dW$. In code, inside the appropriate for-loops, this formula translates into: 1dW[:,:,:,c] \\mathrel&#123;+&#125;= a_slice * dZ[i, h, w, c] 5.1.3 - Computing db:This is the formula for computing $db$ with respect to the cost for a certain filter $W_c$: $$db &#x3D; \\sum_h \\sum_w dZ_{hw} \\tag{3}$$ As you have previously seen in basic neural networks, db is computed by summing $dZ$. In this case, you are just summing over all the gradients of the conv output (Z) with respect to the cost. In code, inside the appropriate for-loops, this formula translates into: 1db[:,:,:,c] += dZ[i, h, w, c] Exercise 5 - conv_backwardImplement the conv_backward function below. You should sum over all the training examples, filters, heights, and widths. You should then compute the derivatives using formulas 1, 2 and 3 above. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def conv_backward(dZ, cache): &quot;&quot;&quot; Implement the backward propagation for a convolution function Arguments: dZ -- gradient of the cost with respect to the output of the conv layer (Z), numpy array of shape (m, n_H, n_W, n_C) cache -- cache of values needed for the conv_backward(), output of conv_forward() Returns: dA_prev -- gradient of the cost with respect to the input of the conv layer (A_prev), numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev) dW -- gradient of the cost with respect to the weights of the conv layer (W) numpy array of shape (f, f, n_C_prev, n_C) db -- gradient of the cost with respect to the biases of the conv layer (b) numpy array of shape (1, 1, 1, n_C) &quot;&quot;&quot; # Retrieve information from &quot;cache&quot; # (A_prev, W, b, hparameters) = None # Retrieve dimensions from A_prev&#x27;s shape # (m, n_H_prev, n_W_prev, n_C_prev) = None # Retrieve dimensions from W&#x27;s shape # (f, f, n_C_prev, n_C) = None # Retrieve information from &quot;hparameters&quot; # stride = None # pad = None # Retrieve dimensions from dZ&#x27;s shape # (m, n_H, n_W, n_C) = None # Initialize dA_prev, dW, db with the correct shapes # dA_prev = None # dW = None # db = None # Pad A_prev and dA_prev # A_prev_pad = zero_pad(A_prev, pad) # dA_prev_pad = zero_pad(dA_prev, pad) #for i in range(m): # loop over the training examples # select ith training example from A_prev_pad and dA_prev_pad # a_prev_pad = None # da_prev_pad = None #for h in range(n_H): # loop over vertical axis of the output volume # for w in range(n_W): # loop over horizontal axis of the output volume # for c in range(n_C): # loop over the channels of the output volume # Find the corners of the current &quot;slice&quot; # vert_start = None # vert_end = None # horiz_start = None # horiz_end = None # Use the corners to define the slice from a_prev_pad # a_slice = None # Update gradients for the window and the filter&#x27;s parameters using the code formulas given above # da_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :] += None # dW[:,:,:,c] += None # db[:,:,:,c] += None # Set the ith training example&#x27;s dA_prev to the unpadded da_prev_pad (Hint: use X[pad:-pad, pad:-pad, :]) # dA_prev[i, :, :, :] = None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE # Making sure your output shape is correct assert(dA_prev.shape == (m, n_H_prev, n_W_prev, n_C_prev)) return dA_prev, dW, db 12345678910111213141516171819202122232425262728# We&#x27;ll run conv_forward to initialize the &#x27;Z&#x27; and &#x27;cache_conv&quot;,# which we&#x27;ll use to test the conv_backward functionnp.random.seed(1)A_prev = np.random.randn(10, 4, 4, 3)W = np.random.randn(2, 2, 3, 8)b = np.random.randn(1, 1, 1, 8)hparameters = &#123;&quot;pad&quot; : 2, &quot;stride&quot;: 2&#125;Z, cache_conv = conv_forward(A_prev, W, b, hparameters)# Test conv_backwarddA, dW, db = conv_backward(Z, cache_conv)print(&quot;dA_mean =&quot;, np.mean(dA))print(&quot;dW_mean =&quot;, np.mean(dW))print(&quot;db_mean =&quot;, np.mean(db))assert type(dA) == np.ndarray, &quot;Output must be a np.ndarray&quot;assert type(dW) == np.ndarray, &quot;Output must be a np.ndarray&quot;assert type(db) == np.ndarray, &quot;Output must be a np.ndarray&quot;assert dA.shape == (10, 4, 4, 3), f&quot;Wrong shape for dA &#123;dA.shape&#125; != (10, 4, 4, 3)&quot;assert dW.shape == (2, 2, 3, 8), f&quot;Wrong shape for dW &#123;dW.shape&#125; != (2, 2, 3, 8)&quot;assert db.shape == (1, 1, 1, 8), f&quot;Wrong shape for db &#123;db.shape&#125; != (1, 1, 1, 8)&quot;assert np.isclose(np.mean(dA), 1.4524377), &quot;Wrong values for dA&quot;assert np.isclose(np.mean(dW), 1.7269914), &quot;Wrong values for dW&quot;assert np.isclose(np.mean(db), 7.8392325), &quot;Wrong values for db&quot;print(&quot;\\033[92m All tests passed.&quot;) Expected Output: dA_mean 1.45243777754 dW_mean 1.72699145831 db_mean 7.83923256462 ## 5.2 Pooling Layer - Backward Pass Next, let’s implement the backward pass for the pooling layer, starting with the MAX-POOL layer. Even though a pooling layer has no parameters for backprop to update, you still need to backpropagate the gradient through the pooling layer in order to compute gradients for layers that came before the pooling layer. 5.2.1 Max Pooling - Backward PassBefore jumping into the backpropagation of the pooling layer, you are going to build a helper function called create_mask_from_window() which does the following: $$ X &#x3D; \\begin{bmatrix}1 &amp;&amp; 3 \\4 &amp;&amp; 2\\end{bmatrix} \\quad \\rightarrow \\quad M &#x3D;\\begin{bmatrix}0 &amp;&amp; 0 \\1 &amp;&amp; 0\\end{bmatrix}\\tag{4}$$ As you can see, this function creates a “mask” matrix which keeps track of where the maximum of the matrix is. True (1) indicates the position of the maximum in X, the other entries are False (0). You’ll see later that the backward pass for average pooling is similar to this, but uses a different mask. Exercise 6 - create_mask_from_windowImplement create_mask_from_window(). This function will be helpful for pooling backward.Hints: np.max() may be helpful. It computes the maximum of an array. If you have a matrix X and a scalar x: A = (X == x) will return a matrix A of the same size as X such that: 12A[i,j] = True if X[i,j] = xA[i,j] = False if X[i,j] != x Here, you don’t need to consider cases where there are several maxima in a matrix. 1234567891011121314151617def create_mask_from_window(x): &quot;&quot;&quot; Creates a mask from an input matrix x, to identify the max entry of x. Arguments: x -- Array of shape (f, f) Returns: mask -- Array of the same shape as window, contains a True at the position corresponding to the max entry of x. &quot;&quot;&quot; # (≈1 line) # mask = None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE return mask 1234567891011121314151617181920np.random.seed(1)x = np.random.randn(2, 3)mask = create_mask_from_window(x)print(&#x27;x = &#x27;, x)print(&quot;mask = &quot;, mask)x = np.array([[-1, 2, 3], [2, -3, 2], [1, 5, -2]])y = np.array([[False, False, False], [False, False, False], [False, True, False]])mask = create_mask_from_window(x)assert type(mask) == np.ndarray, &quot;Output must be a np.ndarray&quot;assert mask.shape == x.shape, &quot;Input and output shapes must match&quot;assert np.allclose(mask, y), &quot;Wrong output. The True value must be at position (2, 1)&quot;print(&quot;\\033[92m All tests passed.&quot;) Expected Output: Why keep track of the position of the max? It’s because this is the input value that ultimately influenced the output, and therefore the cost. Backprop is computing gradients with respect to the cost, so anything that influences the ultimate cost should have a non-zero gradient. So, backprop will “propagate” the gradient back to this particular input value that had influenced the cost. 5.2.2 - Average Pooling - Backward PassIn max pooling, for each input window, all the “influence” on the output came from a single input value–the max. In average pooling, every element of the input window has equal influence on the output. So to implement backprop, you will now implement a helper function that reflects this. For example if we did average pooling in the forward pass using a 2x2 filter, then the mask you’ll use for the backward pass will look like: $$ dZ &#x3D; 1 \\quad \\rightarrow \\quad dZ &#x3D;\\begin{bmatrix}1&#x2F;4 &amp;&amp; 1&#x2F;4 \\1&#x2F;4 &amp;&amp; 1&#x2F;4\\end{bmatrix}\\tag{5}$$ This implies that each position in the $dZ$ matrix contributes equally to output because in the forward pass, we took an average. Exercise 7 - distribute_valueImplement the function below to equally distribute a value dz through a matrix of dimension shape. Hint 123456789101112131415161718192021222324def distribute_value(dz, shape): &quot;&quot;&quot; Distributes the input value in the matrix of dimension shape Arguments: dz -- input scalar shape -- the shape (n_H, n_W) of the output matrix for which we want to distribute the value of dz Returns: a -- Array of size (n_H, n_W) for which we distributed the value of dz &quot;&quot;&quot; # Retrieve dimensions from shape (≈1 line) # (n_H, n_W) = None # Compute the value to distribute on the matrix (≈1 line) # average = None # Create a matrix where every entry is the &quot;average&quot; value (≈1 line) # a = None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE return a 1234567891011121314a = distribute_value(2, (2, 2))print(&#x27;distributed value =&#x27;, a)assert type(a) == np.ndarray, &quot;Output must be a np.ndarray&quot;assert a.shape == (2, 2), f&quot;Wrong shape &#123;a.shape&#125; != (2, 2)&quot;assert np.sum(a) == 2, &quot;Values must sum to 2&quot;a = distribute_value(100, (10, 10))assert type(a) == np.ndarray, &quot;Output must be a np.ndarray&quot;assert a.shape == (10, 10), f&quot;Wrong shape &#123;a.shape&#125; != (10, 10)&quot;assert np.sum(a) == 100, &quot;Values must sum to 100&quot;print(&quot;\\033[92m All tests passed.&quot;) Expected Output: 5.2.3 Putting it Together: Pooling BackwardYou now have everything you need to compute backward propagation on a pooling layer. Exercise 8 - pool_backwardImplement the pool_backward function in both modes (&quot;max&quot; and &quot;average&quot;). You will once again use 4 for-loops (iterating over training examples, height, width, and channels). You should use an if/elif statement to see if the mode is equal to &#39;max&#39; or &#39;average&#39;. If it is equal to ‘average’ you should use the distribute_value() function you implemented above to create a matrix of the same shape as a_slice. Otherwise, the mode is equal to ‘max‘, and you will create a mask with create_mask_from_window() and multiply it by the corresponding value of dA. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def pool_backward(dA, cache, mode = &quot;max&quot;): &quot;&quot;&quot; Implements the backward pass of the pooling layer Arguments: dA -- gradient of cost with respect to the output of the pooling layer, same shape as A cache -- cache output from the forward pass of the pooling layer, contains the layer&#x27;s input and hparameters mode -- the pooling mode you would like to use, defined as a string (&quot;max&quot; or &quot;average&quot;) Returns: dA_prev -- gradient of cost with respect to the input of the pooling layer, same shape as A_prev &quot;&quot;&quot; # Retrieve information from cache (≈1 line) # (A_prev, hparameters) = None # Retrieve hyperparameters from &quot;hparameters&quot; (≈2 lines) # stride = None # f = None # Retrieve dimensions from A_prev&#x27;s shape and dA&#x27;s shape (≈2 lines) # m, n_H_prev, n_W_prev, n_C_prev = None # m, n_H, n_W, n_C = None # Initialize dA_prev with zeros (≈1 line) # dA_prev = None # for i in range(None): # loop over the training examples # select training example from A_prev (≈1 line) # a_prev = None # for h in range(n_H): # loop on the vertical axis # for w in range(n_W): # loop on the horizontal axis # for c in range(n_C): # loop over the channels (depth) # Find the corners of the current &quot;slice&quot; (≈4 lines) # vert_start = None # vert_end = None # horiz_start = None # horiz_end = None # Compute the backward propagation in both modes. # if mode == &quot;max&quot;: # Use the corners and &quot;c&quot; to define the current slice from a_prev (≈1 line) # a_prev_slice = None # Create the mask from a_prev_slice (≈1 line) # mask = None # Set dA_prev to be dA_prev + (the mask multiplied by the correct entry of dA) (≈1 line) # dA_prev[i, vert_start: vert_end, horiz_start: horiz_end, c] += None # elif mode == &quot;average&quot;: # Get the value da from dA (≈1 line) # da = None # Define the shape of the filter as fxf (≈1 line) # shape = None # Distribute it to get the correct slice of dA_prev. i.e. Add the distributed value of da. (≈1 line) # dA_prev[i, vert_start: vert_end, horiz_start: horiz_end, c] += None # YOUR CODE STARTS HERE # YOUR CODE ENDS HERE # Making sure your output shape is correct assert(dA_prev.shape == A_prev.shape) return dA_prev 123456789101112131415161718192021222324252627np.random.seed(1)A_prev = np.random.randn(5, 5, 3, 2)hparameters = &#123;&quot;stride&quot; : 1, &quot;f&quot;: 2&#125;A, cache = pool_forward(A_prev, hparameters)print(A.shape)print(cache[0].shape)dA = np.random.randn(5, 4, 2, 2)dA_prev1 = pool_backward(dA, cache, mode = &quot;max&quot;)print(&quot;mode = max&quot;)print(&#x27;mean of dA = &#x27;, np.mean(dA))print(&#x27;dA_prev1[1,1] = &#x27;, dA_prev1[1, 1]) print()dA_prev2 = pool_backward(dA, cache, mode = &quot;average&quot;)print(&quot;mode = average&quot;)print(&#x27;mean of dA = &#x27;, np.mean(dA))print(&#x27;dA_prev2[1,1] = &#x27;, dA_prev2[1, 1]) assert type(dA_prev1) == np.ndarray, &quot;Wrong type&quot;assert dA_prev1.shape == (5, 5, 3, 2), f&quot;Wrong shape &#123;dA_prev1.shape&#125; != (5, 5, 3, 2)&quot;assert np.allclose(dA_prev1[1, 1], [[0, 0], [ 5.05844394, -1.68282702], [ 0, 0]]), &quot;Wrong values for mode max&quot;assert np.allclose(dA_prev2[1, 1], [[0.08485462, 0.2787552], [1.26461098, -0.25749373], [1.17975636, -0.53624893]]), &quot;Wrong values for mode average&quot;print(&quot;\\033[92m All tests passed.&quot;) Expected Output: ![Snipaste_2021-12-18_12-27-06](https://cdn.jsdelivr.net/gh/iDzforjh/Blog_pic@V1.2/c1pic/Expected Output.png) Congratulations! You’ve completed the assignment and its optional portion. You now understand how convolutional neural networks work, and have implemented all the building blocks of a neural network. In the next assignment you will implement a ConvNet using TensorFlow. Nicely done! See you there.","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://idzforjh.github.io/tags/Machine-Learning/"}]},{"title":"递归与栈","slug":"递归与栈","date":"2021-08-11T01:13:03.000Z","updated":"2021-08-11T01:13:03.000Z","comments":true,"path":"2021/08/11/递归与栈/","link":"","permalink":"https://idzforjh.github.io/2021/08/11/%E9%80%92%E5%BD%92%E4%B8%8E%E6%A0%88/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二叉树","slug":"二叉树","date":"2021-08-10T01:38:48.000Z","updated":"2021-08-16T02:36:13.000Z","comments":true,"path":"2021/08/10/二叉树/","link":"","permalink":"https://idzforjh.github.io/2021/08/10/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"树的定义：树（Tree）是n（n≥0）个结点的有限集，它或为空树（n &#x3D; 0）；或为非空树，对于非空树T： 有且仅有一个称之为根的结点； 除根结点以外的其余结点可分为m（m＞0）个互不相交的有限集T1, T2, …, Tm, 其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。","text":"树的定义：树（Tree）是n（n≥0）个结点的有限集，它或为空树（n &#x3D; 0）；或为非空树，对于非空树T： 有且仅有一个称之为根的结点； 除根结点以外的其余结点可分为m（m＞0）个互不相交的有限集T1, T2, …, Tm, 其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。 二叉树普通树（多叉树）若不转化为二叉树，则运算很难实现 为何要重点研究每结点最多只有两个 “叉” 的树？ 二叉树的结构最简单，规律性最强； 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。 二叉树与树的区别： 每个结点至多只有两棵子树 二叉树的子树有左右之分，其次序不能颠倒 树 - 结构定义12345typedef struct Node&#123; int data; struct Node *next;&#125;Node, *LinkedList; 二叉树 - 结构定义12345typedef struct Node&#123; int data; struct Node *next[3];&#125;Node, *Tree; 二叉树的性质 在二叉树的第i层上至多有2^i-1个结点。 深度为k的二叉树至多有2^k-1个结点。 对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2＋1 （即n0&#x3D;n2+1） 遍历二叉树遍历规则 前序遍历：根 - 左 - 右 中序遍历：左 - 根 - 右 后序遍历：左 - 右 - 根 定义节点123456typedef struct Node&#123; // 节点数据域 int key; // 节点指针域 struct Node *lchild, *rchild;&#125;Node 新建树规则1234567Node *getNewNode(int key)&#123; // malloc 分配一块连续的内存 Node *p = (Node*)malloc(sizeof(Node)); p -&gt; key = key; p -&gt; lchild = p -&gt; rchild = nullptr; return p;&#125; 节点插入规则1234567891011// 如果 key 是偶数则插入树的左侧，奇数则为右侧Node *insertToTree(Node *root, int key)&#123; if(root == nullptr) return getNewNode(key); if (rand() % 2) &#123; root -&gt; lchild = insertToTree(root -&gt; lchild, key); &#125; else &#123; root -&gt; rchild = insertToTree(root -&gt; rchild, key); &#125; return root;&#125; 递归遍历123456789101112131415161718192021222324252627// 中序遍历void inOrder(Node *root)&#123; if(root == nullptr) return ; inOrder(root -&gt; lchild); cout &lt;&lt; root -&gt; key &lt;&lt; &quot; &quot;; inOrder(root -&gt; rchild); return ;&#125;// 前序遍历void preOrder(Node *root)&#123; if(root == nullptr) return ; cout &lt;&lt; root -&gt; key &lt;&lt; &quot; &quot;; preOrder(root -&gt; lchild); preOrder(root -&gt; rchild); return ;&#125;// 后序遍历void binOrder(Node *root)&#123; if(root == nullptr) return; binOrder(root -&gt; rchild); binOrder(root -&gt; lchild); cout &lt;&lt; root -&gt; key &lt;&lt; &quot; &quot;; return ; &#125; 二叉树的应用二叉树的基本应用 理解高级数据结构的基础二叉树 完全二叉树 堆 优先队列 多叉树&#x2F;森林 字典树 AC自动机 并查集 二叉排序树 AVL树 2-3树 红黑树 B-树&#x2F;B+树 练习递归技巧的最佳选择设计&#x2F;理解递归程序 ： 数学归纳法 —— 结构归纳法 赋予递归函数一个明确定义 思考边界条件 实现递归过程 经典面试题144. 二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 123456789101112131415161718192021222324252627282930313233343536373839/** * * 2021-8-12 * LeetCode144 二叉树的前序遍历 * **/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// Definition for a binary tree node.struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution &#123;public: // 深度优先搜索 void dfs(TreeNode *root, vector&lt;int&gt; &amp;ans)&#123; if(root == nullptr) return; ans.push_back(root -&gt; val); dfs(root -&gt; left, ans); dfs(root -&gt; right, ans); return; &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; dfs(root, ans); return ans; &#125;&#125;; 589. N 叉树的前序遍历给定一个 N 叉树，返回其节点值的 前序遍历 。 N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * * 2021-8-12 * LeetCode589 N 叉树的前序遍历 * **/ #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;class Solution &#123;public: void dfs(Node *root, vector&lt;int&gt; &amp;ans)&#123; if(root == nullptr) return ; ans.push_back(root -&gt; val); for(int i = 0; i &lt; root -&gt; children.size(); i++)&#123; dfs(root -&gt; children[i], ans); &#125; return ; &#125; vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; ans; dfs(root, ans); return ans; &#125;&#125;; 226. 翻转二叉树翻转一棵二叉树。 123456789101112131415161718192021222324252627282930313233/** * * 2021-8-12 * LeetCode226 翻转二叉树 * **/ #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// Definition for a binary tree node. struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;; class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root == nullptr) return; swap(root -&gt; left, root -&gt; right); invertTree(root -&gt; left); invertTree(root -&gt; right); return root; &#125;&#125;; 剑指 Offer 32 - II. 从上到下打印二叉树 II请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * * 2021-8-12 * 箭指Offer32 从上到下打印二叉树 II * **/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// Definition for a binary tree node.struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution&#123;public: void dfs(TreeNode *root, vector&lt;vector&lt;int&gt; &gt; &amp;ans, int deep)&#123; if (root == nullptr) return; // c++ 语言特性 if (deep == ans.size())&#123; ans.push_back(vector&lt;int&gt;()); &#125; ans[deep].push_back(root -&gt; val); dfs(root -&gt; left, ans, deep + 1); dfs(root -&gt; right, ans, deep + 1); return; &#125; vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; ans; dfs(root, ans, 0); return ans; &#125;&#125;; 107. 二叉树的层序遍历 II给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 123456789101112131415161718192021222324252627class Solution&#123;public: void dfs(TreeNode *root, vector&lt;vector&lt;int&gt; &gt; &amp;ans, int deep) &#123; if (root == nullptr) return; if (deep == ans.size()) &#123; ans.push_back(vector&lt;int&gt;()); &#125; ans[deep].push_back(root-&gt;val); dfs(root-&gt;left, ans, deep + 1); dfs(root-&gt;right, ans, deep + 1); return; &#125; vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; ans; dfs(root, ans, 0); for (int i = 0, j = ans.size() - 1; i &lt; j; i++, j--)&#123; swap(ans[i], ans[j]); &#125; return ans; &#125;&#125;; 103. 二叉树的锯齿形层序遍历给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * * 2021-8-12 * LeetCode103 二叉树的锯齿形层序遍历 * **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// Definition for a binary tree node.struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution&#123;public: void dfs(TreeNode *root,vector&lt;vector&lt;int&gt; &gt; &amp;ans, int deep)&#123; if (root == nullptr) return ; if (deep == ans.size())&#123; ans.push_back(vector&lt;int&gt;()); &#125; dfs(root -&gt; left, ans, deep + 1); dfs(root -&gt; right, ans, deep + 1); ans[deep].push_back(root -&gt; val); &#125; vector&lt;vector&lt;int&gt; &gt; zigzagLevelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; ans; dfs(root, ans, 0); for(int i = 0; i &lt; ans.size(); i++)&#123; if(i % 2 == 1)&#123; reverse(ans[i].begin(), ans[i].end()); &#125; &#125; return ans; &#125;&#125;; 110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * * 2021-8-12 * LeetCode110 平衡二叉树 * **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// Definition for a binary tree node.struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution&#123;public: // 后序遍历 int dfs(TreeNode *root)&#123; if (root == nullptr) return 0; int l = dfs(root -&gt; left); int r = dfs(root -&gt; right); if (l == -2 || r == -2) return -2; if (abs(l - r) &gt; 1)&#123; // 失横 return -2; &#125; return max(l, r) + 1; &#125; bool isBalanced(TreeNode *root) &#123; return dfs(root) &gt;= 0; &#125;&#125;; 112. 路径总和给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。 叶子节点 是指没有子节点的节点。 123456789101112131415161718192021222324252627282930313233343536/** * * 2021-8-12 * LeetCode112 路径总和 * **/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// Definition for a binary tree node.struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution&#123;public: bool hasPathSum(TreeNode *root, int targetSum)&#123; if(root == nullptr) return false; if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123; return targetSum == root-&gt;val; &#125; targetSum = targetSum - root-&gt;val; //hasPathSum(root, targetSum - root-&gt;val); return hasPathSum(root -&gt; left, targetSum) || hasPathSum(root -&gt; right, targetSum); &#125;&#125;; 105. 从前序与中序遍历序列构造二叉树给定一棵树的前序遍历 preorder 与中序遍历 inorder。请构造二叉树并返回其根节点。 例： 前序遍历 [3, 9, 20, 15, 7] 中序遍历 [9, 3, 15, 20, 7] 需要根据前序遍历先确定根节点是 3，然后根据中序遍历结果确定左、右子节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * * 2021-8-12 * LeetCode105 从前序与中序遍历序列构造二叉树 * **/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std; // Definition for a binary tree node.struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution&#123;public: unordered_map&lt;int, int&gt; ind; // 使用字典优化查找速度 TreeNode *__buildTree( vector&lt;int&gt; &amp;preorder, int l1, int r1, vector&lt;int&gt; &amp;inorder, int l2, int r2) &#123; if (l1 == r1) return nullptr; TreeNode *root = new TreeNode(preorder[l1]); // 根节点 int pos = ind[preorder[l1]]; // 指向根节点 int n = pos - l2 + 1; root-&gt;left = __buildTree(preorder, l1 + 1, l1 + n, inorder, l2, pos); root-&gt;right = __buildTree(preorder, l1 + n, r1, inorder, l2 + n, r2); return root; &#125; TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; // 桶排序 for (int i = 0; i &lt; inorder.size(); i++) &#123; ind[inorder[i]] = i; // 找到元素下标 // ind[3] = 1 3的下标为1 &#125; return __buildTree(preorder, 0, preorder.size(), inorder, 0, inorder.size()); &#125;&#125;; 222. 完全二叉树的节点个数给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 1234567891011121314151617181920212223242526272829/** * * 2021-8-13 * LeetCode222 完全二叉树的节点个数 * **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// Definition for a binary tree node. struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; &#125;;class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(root == nullptr) return 0; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1; &#125;&#125;; 剑指 Offer 54. 二叉搜索树的第k大节点给定一棵二叉搜索树，请找出其中第k大的节点。 123456789101112131415161718192021222324252627282930313233343536373839/** * * 2021-8-15 * 箭指Offer354 二叉搜索树的第k大节点 * * 左子节点是最小的，右子节点是最大的 * **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// Definition for a binary tree node. struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: int countNodes(TreeNode* root)&#123; if(root == nullptr) return 0; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1; &#125; int kthLargest(TreeNode* root, int k) &#123; int n = countNodes(root-&gt;right); if(n == k - 1)&#123; // 找到第k大个数 return root-&gt;val; &#125; if(n &gt;= k)&#123; return kthLargest(root-&gt;right, k); &#125; return kthLargest(root-&gt;left, k - n - 1); &#125;&#125;; 剑指 Offer 26. 树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 12345678910111213141516171819202122232425262728293031323334353637/** * * 2021-8-15 * 剑指Offer26 树的子结构 * **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// Definition for a binary tree node.struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution&#123;public: bool is_match(TreeNode *A, TreeNode *B)&#123; if(B == NULL) return true; if(A == NULL) return false; if(A-&gt;val != B-&gt;val) return false; return is_match(A-&gt;left, B-&gt;left) &amp;&amp; is_match(A-&gt;right, B-&gt;right); &#125; bool isSubStructure(TreeNode *A, TreeNode *B) &#123; if(A == NULL || B == NULL) return false; if(A-&gt;val == B-&gt;val &amp;&amp; is_match(A, B)) return true; return isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B); &#125;&#125;; 662. 二叉树最大宽度给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * * 2021-8-16 * LeetCode662 二叉树最大宽度 * **/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;// Definition for a binary tree node. struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution &#123;public: long long maxW = 0; unordered_map&lt;int, long long&gt; mp; void dfs(TreeNode *root, int level, long long index)&#123; if(root == nullptr) return ; if(!mp.count(level))&#123; mp[level] = index; &#125; maxW = max(maxW, index - mp[level] + 1); index = index - mp[level]; // 防止溢出 dfs(root-&gt;left, level + 1, index * 2); dfs(root-&gt;right, level + 1, index * 2 + 1); return; &#125; int widthOfBinaryTree(TreeNode* root) &#123; dfs(root, 1, 1); return maxW; &#125;&#125;; 968. 监控二叉树给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * * 2021-8-16 * LeetCode968. 监控二叉树 * **/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;// Definition for a binary tree node. struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution &#123; // 后续遍历public: int ans = 0; int dfs(TreeNode *root)&#123; if(root == nullptr) return ; /** * 无法被看到的节点为 1 * 能被看到，但无监控的节点 为2 * 能被看到，且有监控的节点 为3 **/ int l = dfs(root-&gt;left); int r = dfs(root-&gt;right); if(l == 0 || r ==0)&#123; ans++; return 2; &#125;else if(l == 2 || r == 2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; int minCameraCover(TreeNode* root) &#123; if(root == nullptr) return 0; if(dfs(root) == 0)&#123; ans++; &#125;; return ans; &#125;&#125;;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/tags/Algorithms/"}]},{"title":"线程池与任务队列","slug":"线程池与任务队列","date":"2021-08-05T07:42:07.000Z","updated":"2021-08-09T15:06:10.000Z","comments":true,"path":"2021/08/05/线程池与任务队列/","link":"","permalink":"https://idzforjh.github.io/2021/08/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/","excerpt":"线程池与任务队列栈和队列也是线性表，它们是操作受限的线性表。","text":"线程池与任务队列栈和队列也是线性表，它们是操作受限的线性表。 栈和队列栈 的定义和特点 定义：限定仅在表尾进行插入或删除操作的线性表，表尾—栈顶，表头—栈底，不含元素的空表称空栈。 特点：先进后出（FILO）或后进先出（LIFO）。 队列 的定义和特点 定义：限定在表的一端进行插入，而在另一端进行删除操作的线性表。允许插入的一端—队尾，允许删除的一端—栈头，不含元素的空表称空队列。 特点：先进先出（FIFO）。 LeetCode经典问题著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。来源：http://byzy.website/ 86. 分隔链表给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 123456789101112131415161718192021222324252627282930313233343536373839/** * * 2021-7-31 * LeetCode86 分隔链表 * **/#include&lt;iostream&gt;using namespace std; // Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;; class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode h1, h2, *p1 = &amp;h1, *p2 = &amp;h2; for(ListNode *p = head, *q ; p != nullptr ; p = q)&#123; q = p -&gt; next; p -&gt; next = nullptr; if(p -&gt; val &lt; x)&#123; p1-&gt;next = p; p1 = p; &#125; else &#123; p2 -&gt; next = p; p2 = p; &#125; &#125; p1 -&gt; next = h2.next; return h1.next; &#125; &#125;; 138. 复制带随机指针的链表给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * * 2021-7-31 * LeetCode138 复制带随机指针的链表 * **/#include&lt;iostream&gt;using namespace std;// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; // p 防止头丢掉，new_head 最后指向新连标头节点 Node *p = head, *q, *new_head; // 1. 复制每一个节点 while (p) &#123; q = new Node(p-&gt;val); q -&gt; next = p -&gt; next; q -&gt; random = p -&gt; random; p -&gt; next = q; p = q -&gt;next; &#125; p = head -&gt; next; while(p)&#123; // 2. 将复制的新节点的random都指向random的下个节点 if(p-&gt;random != nullptr)&#123; p -&gt; random = p -&gt;random -&gt; next; &#125; p = p-&gt;next; if(p)&#123; p = p -&gt; next; &#125; &#125; new_head = head -&gt; next; p = head; while (p) &#123; q = p -&gt; next; // 3. 绕过复制节点 p -&gt; next = q -&gt; next; if(p-&gt;next)&#123; q-&gt;next = p -&gt; next -&gt; next; &#125; p = p -&gt; next; &#125; return new_head; &#125;&#125;; 622. 设计循环队列设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * * 2021-8-5 * LeetCode622 设计循环队列 * * \b基于数组的队列 * **/ #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class MyCircularQueue &#123;public: //动态数组 vector&lt;int&gt; v; int head, tail, cnt, k; // 构造 MyCircularQueue(int k) : v(k), k(k), head(0), tail(0), cnt(0) &#123; &#125; // 插入 bool enQueue(int value) &#123; if(isFull()) return false; v[tail++] = value; tail %= k; cnt += 1; return true; &#125; // 删除 bool deQueue() &#123; if(isEmpty()) return false; cnt -= 1; return (head = (head + 1) % k) || true; &#125; int Front() &#123; if(isEmpty()) return -1; return v[head]; &#125; int Rear() &#123; if(isEmpty()) return -1; return v[(tail - 1 + k) % k]; &#125; bool isEmpty() &#123; return cnt == 0; &#125; bool isFull() &#123; return cnt == k; &#125;&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj-&gt;enQueue(value); * bool param_2 = obj-&gt;deQueue(); * int param_3 = obj-&gt;Front(); * int param_4 = obj-&gt;Rear(); * bool param_5 = obj-&gt;isEmpty(); * bool param_6 = obj-&gt;isFull(); */ (tail - 1 + k) % k 存在tail指针在循环队列头部的情况为了防止溢出，需要通过取余方式保证 641. 设计循环双端队列设计实现双端队列。你的实现需要支持以下操作： MyCircularDeque(k)：构造函数,双端队列的大小为k。 insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。 insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。 deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。 deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。 getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。 getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。 isEmpty()：检查双端队列是否为空。 isFull()：检查双端队列是否满了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * * 2021-8-6 * LeetCode641 设计循环双端队列 * **/ #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class MyCircularDeque &#123;public: vector&lt;int&gt; v; int head, tail, k, cnt; /** Initialize your data structure here. Set the size of the deque to be k. */ MyCircularDeque(int k) : v(k), k(k), cnt(0), head(0), tail(0)&#123;&#125; /** Adds an item at the front of Deque. Return true if the operation is successful. */ bool insertFront(int value) &#123; if(isFull()) return false; head = (head - 1 + k) % k; v[head] = value; cnt += 1; return true; &#125; /** Adds an item at the rear of Deque. Return true if the operation is successful. */ bool insertLast(int value) &#123; if(isFull()) return false; v[tail++] = value; tail %= k; cnt += 1; return true; &#125; /** Deletes an item from the front of Deque. Return true if the operation is successful. */ bool deleteFront() &#123; if (isEmpty()) return false; head = (head + 1) % k; cnt -= 1; return true; &#125; /** Deletes an item from the rear of Deque. Return true if the operation is successful. */ bool deleteLast() &#123; if(isEmpty()) return false; tail = (tail - 1 + k) % k; cnt -= 1; return true; &#125; /** Get the front item from the deque. */ int getFront() &#123; if(isEmpty()) return -1; return v[head]; &#125; /** Get the last item from the deque. */ int getRear() &#123; if(isEmpty()) return -1; return v[(tail - 1 +k) % k]; &#125; /** Checks whether the circular deque is empty or not. */ bool isEmpty() &#123; return cnt == 0; &#125; /** Checks whether the circular deque is full or not. */ bool isFull() &#123; return cnt == k; &#125;&#125;;/** * Your MyCircularDeque object will be instantiated and called as such: * MyCircularDeque* obj = new MyCircularDeque(k); * bool param_1 = obj-&gt;insertFront(value); * bool param_2 = obj-&gt;insertLast(value); * bool param_3 = obj-&gt;deleteFront(); * bool param_4 = obj-&gt;deleteLast(); * int param_5 = obj-&gt;getFront(); * int param_6 = obj-&gt;getRear(); * bool param_7 = obj-&gt;isEmpty(); * bool param_8 = obj-&gt;isFull(); */ 1670. 设计前中后队列请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。 请你完成 FrontMiddleBack 类： FrontMiddleBack() 初始化队列。 void pushFront(int val) 将 val 添加到队列的 最前面 。 void pushMiddle(int val) 将 val 添加到队列的 正中间 。 void pushBack(int val) 将 val 添加到队里的 最后面 。 int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。 请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说： 将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, **6**, 3, 4, 5] 。 从 [1, 2, **3**, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/** * * 2021-8-6 * LeetCode1670 设计前中后队列 * 链表队列 * **/#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// 链表节点结构class Node&#123; public: int val; // 双向链表 Node *next, *pre; Node(int val = 0, Node *next = nullptr, Node *pre = nullptr): val(val), next(next), pre(pre)&#123;&#125; // 执行功能 void insert_pre(Node *p)&#123; // this 是当前节点 p -&gt; pre = pre; p -&gt; next = this; if(this -&gt; pre) this-&gt;pre-&gt;next = p; this -&gt; pre = p; return ; &#125; void insert_next(Node *p)&#123; p-&gt;pre = this; p-&gt;next = this-&gt;next; if(this-&gt;next) this-&gt;next-&gt;pre = p; this -&gt; next = p; return ; &#125; void delete_pre()&#123; if(this-&gt;pre == nullptr) return ; Node *p = this -&gt; pre; this -&gt; pre = p -&gt; pre; if(p-&gt;pre) p-&gt;pre-&gt;next = this; delete p; return ; &#125; void delete_next()&#123; if(this-&gt;next == nullptr) return; Node *p = this -&gt; next; this -&gt; next = p -&gt; next; if(p-&gt;next) p-&gt;next-&gt;pre = this; delete p; return ; &#125;&#125;;// 用链表封装循环队列class Queue&#123; public: // 哨兵节点 Node head, tail; int cnt; Queue():cnt(0)&#123; head.next = &amp;tail; head.pre = nullptr; tail.pre = &amp;head; tail.next = nullptr; &#125; void push_back(int val)&#123; tail.insert_pre(new Node(val)); cnt++; return ; &#125; void push_front(int val)&#123; head.insert_next(new Node(val)); cnt++; return ; &#125; int pop_back()&#123; if(isEmpty()) return -1; int ret = tail.pre -&gt; val; tail.delete_pre(); cnt--; return ret; &#125; int pop_front()&#123; if(isEmpty()) return -1; int ret = head.next -&gt; val; head.delete_next(); cnt--; return ret; &#125; int front()&#123; return head.next-&gt;val; &#125; int back()&#123; return tail.pre-&gt;val; &#125; int isEmpty()&#123; return head.next == &amp;tail; &#125; int size()&#123; return cnt; &#125;&#125;;// 通过两个队列实现模拟 前中后 队列class FrontMiddleBackQueue &#123; public: Queue q1, q2; FrontMiddleBackQueue() &#123;&#125; void pushFront(int val) &#123; q1.push_front(val); update(); return; &#125; void pushMiddle(int val) &#123; if(q1.size() &gt; q2.size())&#123; q2.push_front(q1.back()); q1.pop_back(); &#125; q1.push_back(val); return ; &#125; void pushBack(int val) &#123; q2.push_back(val); update(); return ; &#125; int popFront() &#123; if(isEmpty()) return -1; int val = q1.pop_front(); update(); return val; &#125; int popMiddle() &#123; if(isEmpty()) return -1; int val = q1.pop_back(); update(); return val; &#125; int popBack() &#123; if(isEmpty()) return -1; int val; if(q2.isEmpty()) val = q1.pop_back(); else val = q2.pop_back(); update(); return val; &#125; bool isEmpty()&#123; return q1.size() == 0; &#125; void update()&#123; if(q1.size() &lt; q2.size())&#123; q1.push_back(q2.front()); q2.pop_front(); &#125; if(q1.size() == q2.size() + 2)&#123; q2.push_front(q1.back()); q1.pop_back(); &#125; return ; &#125;&#125;;/** * Your FrontMiddleBackQueue object will be instantiated and called as such: * FrontMiddleBackQueue* obj = new FrontMiddleBackQueue(); * obj-&gt;pushFront(val); * obj-&gt;pushMiddle(val); * obj-&gt;pushBack(val); * int param_4 = obj-&gt;popFront(); * int param_5 = obj-&gt;popMiddle(); * int param_6 = obj-&gt;popBack(); */ 933. 最近的请求次数写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 保证 每次对 ping 的调用都使用比之前更大的 t 值。 1234567891011121314151617181920212223242526272829/** * * 2021-8-6 * LeetCode933 最近的请求次数 * **/ #include&lt;iostream&gt;#include &lt;deque&gt; using namespace std;class RecentCounter &#123;public: // 双栈队列 deque&lt;int&gt; q; RecentCounter() &#123;&#125; int ping(int t) &#123; q.push_back(t); while(t - q.front() &gt; 3000) q.pop_front(); return q.size(); &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj-&gt;ping(t); */ 面试题 17.09. 第 k 个数有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。 12345678910111213141516171819202122232425262728293031/** * * 2021-8-8 * 面试题 17.09. 第 k 个数 * 三指针 * **/ #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int getKthMagicNumber(int k) &#123; // 大小是k，每一位初始化为0 vector&lt;int&gt; vec(k, 0); int p3 = 0, p5 = 0, p7 = 0; // 第一个357数是1 vec[0] = 1; for(int i = 1; i &lt; k; i++)&#123; // 寻找每一次357计算结果中最小的一个 vec[i] = min(vec[p3] * 3, min(vec[p5] *5, vec[p7] * 7)); if(vec[i] == vec[p3] * 3) p3++; if(vec[i] == vec[p5] * 5) p5++; if(vec[i] == vec[p7] * 7) p7++; &#125; return vec[k-1]; &#125; &#125;; 859. 亲密字符串给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与B 相等的结果，就返回 true ；否则返回 false 。 交换字母的定义是取两个下标 i 和 j （下标从 0 开始），只要 i!=j 就交换 A[i] 和A[j] 处的字符。例如，在 &quot;abcd&quot; 中交换下标 0 和下标 2 的元素可以生成 &quot;cbad&quot; 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * * 2021-8-8 * LeetCode859 亲密字符串 * * A = ‘ab’ , B = &#x27;ba&#x27; return true * A = ‘ab’ , B = &#x27;ab&#x27; return false * A = ‘abb’ , B = &#x27;abb&#x27; return true * 需有判断是否有重复字段是否可以一次交换完成。 * **/ #include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;class Solution &#123;public: // 判断 int check(string a)&#123; int cnt[26] = &#123;0&#125;; for(int i; i &lt; a.size(); i++)&#123; // 有重复 if(cnt[a[i] - &#x27;a&#x27;] != 0) return true; // 没有重复则继续检测 cnt[a[i] - &#x27;a&#x27;] += 1; &#125; return false; &#125; bool buddyStrings(string a, string b) &#123; if(a == b) return check(a); // 如果长度完全相等，查看是否有重复字符 if(a.size() != b.size()) return false; int i = 0, j = 0; while(a[i] == b[i]) i++; // 找到第一个不相等的位置 for(int j = i + 1; j &lt; a.size(); j++)&#123; // 找到第二个不相等的位置 if(a[j] == b[j]) continue; if(a[j] != b[i] || b[j] != a[i]) return false; // 判断第一个和第二个不相等的位置是否交叉相等（是否可以一次完成置换） break; &#125; if(j == a.size()) return false; for(int j = j + 1; j&lt; a.size(); j++)&#123; // 检查后续是否有不相等的字符 if(a[j] != b[j]) return false; &#125; return true; &#125;&#125;; 860. 柠檬水找零在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * * 2021-8-9 * LeetCode860 柠檬水找零 * **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution&#123;public: bool lemonadeChange(vector&lt;int&gt; &amp;bills) &#123; int cnt5 = 0, cnt10 = 0; for (int i = 0; i &lt; bills.size(); i++) &#123; switch (bills[i]) &#123; case 5: cnt5++; break; case 10: if (cnt5 == 0) return false; cnt5--, cnt10++; break; case 20: if (cnt10 != 0 &amp;&amp; cnt5 != 0) &#123; cnt10 -= 1, cnt5 -= 1; &#125; else if (cnt5 &gt;= 3) &#123; cnt5 -= 3; &#125; else &#123; return false; &#125; break; &#125; &#125; return true; &#125;&#125;; 969. 煎饼排序给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。 一次煎饼翻转的执行过程如下： 选择一个整数 k ，1 &lt;= k &lt;= arr.length 反转子数组 arr[0...k-1]（下标从 0 开始） 例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。 以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。 12345678910111213141516171819202122232425262728293031323334353637383940/** * * 2021-8-9 * LeetCode969 煎饼排序 * **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: void reverse(vector&lt;int&gt; &amp;arr, int n, vector&lt;int&gt; &amp;ind)&#123; for(int i = 0, j = n; i &lt; j; i++, j--)&#123; swap(arr[i], arr[j]); ind[arr[i]] = i; ind[arr[j]] = j; &#125; return ; &#125; vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; ind(arr.size() + 1); vector&lt;int&gt; ret; // 答案数组 for(int i = 0; i &lt; arr.size(); i++) ind [arr[i]] = i; for(int i = arr.size(); i &gt;= 1; i--)&#123; // 最大元素下标 if(ind[i] != 0)&#123; ret.push_back(ind[i] + 1); // &#125; reverse(arr, ind[i], ind); // arr数组前ind[i]进行翻转 if(i != 1) ret.push_back(i); reverse(arr, i - 1, ind); &#125; return ret; &#125;&#125;; 621. 任务调度器给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的 最短时间 。 1234567891011121314151617181920212223242526/** * * 2021-8-9 * LeetCode621 任务调度器 * * (A的数量 - 1)（出现次数最多的任务）* (冷却数量 + 1) + 出现次数最多的任务有几种 **/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution&#123;public: int leastInterval(vector&lt;char&gt; &amp;tasks, int n)&#123; int cnt[26] = &#123;0&#125;; for (int i = 0; i &lt; tasks.size(); i++)&#123; cnt[tasks[i] - &#x27;A&#x27;] += 1; &#125; sort(cnt, cnt + 26); int m = 0; for (int i = 25; i &gt;= 0 &amp;&amp; cnt[i] == cnt[25]; i--, m++); return max((int)tasks.size(), (cnt[25] - 1) * (n + 1) + m); &#125;&#125;;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/tags/Algorithms/"}]},{"title":"链表","slug":"链表","date":"2021-08-04T12:54:03.000Z","updated":"2021-08-05T07:44:22.000Z","comments":true,"path":"2021/08/04/链表/","link":"","permalink":"https://idzforjh.github.io/2021/08/04/%E9%93%BE%E8%A1%A8/","excerpt":"链表与经典问题线性表的定义：由n(n≥0)个数据特性相同的元素构成的有限序列。","text":"链表与经典问题线性表的定义：由n(n≥0)个数据特性相同的元素构成的有限序列。 链表基础 头指针: 是指向链表中第一个结点（或为头结点或开始结点）的指针。单链表可由一个头指针唯一确定。 头结点: 是在链表的开始结点之前附设的一个结点；数据域内只放空表标志和表长等信息; 开始结点: 是指链表中存储线性表第一个数据元素a1的结点。 LeetCode经典问题141.环形链表给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 1234567891011121314151617181920212223242526272829303132333435/** * 2021-7-26 * LeetCode141 环形链表 * * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */#include&lt;iostream&gt;using namespace std;class Solution &#123;public:struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;; bool hasCycle(ListNode *head) &#123; if(head == NULL) return false; ListNode *p = head, *q = head-&gt;next; while (p!=q &amp;&amp; q &amp;&amp; q-&gt;next) &#123; p = p -&gt; next; q = q -&gt; next -&gt; next; &#125; return p == q; &#125;&#125;; 142. 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 2021-7-26 * LeetCode141 环形链表II * * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */#include&lt;iostream&gt;using namespace std;class Solution &#123;public:struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; ListNode *detectCycle(ListNode *head) &#123; if(head == NULL) return NULL; ListNode *p = head, *q = head; // while判断 q 以及 q-&gt;next 是否为空，防止程序崩溃。 while (q &amp;&amp; q-&gt;next) &#123; p = p-&gt;next; q = q-&gt;next-&gt;next; if( p == q)&#123; p = head; while ( p != q) &#123; p = p-&gt;next; q = q-&gt;next; &#125; return p; &#125; &#125; return NULL; &#125;&#125;; 202.快乐数编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。如果 n 是快乐数就返回 true ；不是，则返回 false 。 12345678910111213141516171819202122232425262728/** * * 2021-7-27 * LeetCode202 快乐数 * **/class Solution &#123;public: int getNext(int x)&#123; int z = 0; while (x) &#123; z += (x%10) * (x%10); x /= 10; &#125; return z; &#125; bool isHappy(int n) &#123; int p = n, q = n; do&#123; p = getNext(p); q = getNext(getNext(q)); &#125; while (q!=p &amp;&amp; p != 1); return q == 1; &#125;&#125;; 206. 反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * * 2021-7-27 * LeetCode206 反转链表 * **/#include&lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;;class Solution1 &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr || head -&gt; next == nullptr) return head; ListNode *pre = nullptr, *cur = head, *p = head-&gt;next; while (cur)&#123; cur -&gt; next = pre; pre = cur; /* cur = p; p = p-&gt;next; */ // 先将 p 赋值给 cur ，如果 cur == nullptr 则为false，不会执行 p = p-&gt;next (cur = p) &amp;&amp; (p = p-&gt;next); &#125; return pre; &#125;&#125;;// 递归class Solution2&#123; public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr || head -&gt; next == nullptr) return head; ListNode *tail = head-&gt;next, *p = reverseList(head-&gt;next); head -&gt; next = tail -&gt; next; tail -&gt; next = head; return p; &#125;&#125;; 92. 反转链表 II给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 123456789101112131415161718192021222324252627282930313233343536373839/** * * 2021-7-27 * LeetCode92 反转链表II * **/#include&lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;;class Solution &#123;public: ListNode* reverseN(ListNode* head, int right) &#123; if(right == 1) return head; ListNode *tail = head-&gt;next, *p = reverseN(head-&gt;next, right-1); head -&gt; next = tail -&gt; next; tail -&gt; next = head; return p; &#125; ListNode* reverseBetween(ListNode* head, int left, int right) &#123; // 哨兵节点 ListNode ret(0,head), *p = &amp;ret; int cnt = right - left + 1; // 找到需要翻转的左边界 while (--left) p = p-&gt;next; p-&gt;next = reverseN(p-&gt;next, cnt); return ret.next; &#125;&#125;; 25. K 个一组翻转链表给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * * 2021-7-27 * LeetCode25 K 个一组翻转链表 * **/#include&lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;;class Solution &#123;public: ListNode* __reverseK(ListNode* head, int right) &#123; if(right == 1) return head; ListNode *tail = head-&gt;next, *p = __reverseK(head-&gt;next, right-1); head -&gt; next = tail -&gt; next; tail -&gt; next = head; return p; &#125; ListNode* reverseK(ListNode* head, int k) &#123; ListNode *p = head; int cnt = k; while (--k &amp;&amp; p) p = p-&gt;next; if(p == nullptr) return head; return __reverseK(head, cnt); &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; ListNode ret(0, head), *p = &amp;ret, *q = p-&gt;next; while ((p-&gt;next = reverseK(q, k)) != q) &#123; p = q; q = q-&gt;next; &#125; return ret.next; &#125;&#125;; 61. 旋转链表给你一个链表的头节点head，旋转链表，将链表每个节点向右移动 k 个位置。 1234567891011121314151617181920212223242526272829303132333435363738/** * * 2021-7-27 * LeetCode61 旋转链表 * **/#include&lt;iostream&gt;using namespace std; Definition for singly-linked list. struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;; class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head == nullptr) return nullptr; int n = 1; ListNode *p = head; while (p-&gt;next) &#123; p = p-&gt;next, n++; &#125; p-&gt;next = head; k %= n, k = n - k; while (k--) p = p-&gt;next; head = p -&gt; next; p -&gt; next = nullptr; return head; &#125;&#125;; 19. 删除链表的倒数第 N 个结点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 123456789101112131415161718192021222324252627282930/** * * 2021-7-28 * LeetCode19 删除链表的倒数第 N 个结点 * **/#include&lt;iostream&gt;using namespace std;// Definition for singly-linked list. struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;;class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; ListNode ret(0, head), *p = &amp;ret, *q = head; while (n--) q = q -&gt; next; while (q != nullptr) p = p -&gt; next, q = q-&gt;next; p -&gt; next = p -&gt;next-&gt;next; return ret.next; &#125;&#125;; 83. 删除排序链表中的重复元素存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 123456789101112131415161718192021222324252627282930313233343536/** * * 2021-7-28 * LeetCode83 删除链表中的重复元素 * **/ #include&lt;iostream&gt;using namespace std;//Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; &#125;;class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *p = head; while (p-&gt;next) &#123; if(p-&gt;val == p-&gt;next-&gt;val)&#123; p-&gt;next = p-&gt;next-&gt;next; &#125;else&#123; p = p-&gt;next; &#125; &#125; return head; &#125;&#125;; 82. 删除排序链表中的重复元素 II存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。 1234567891011121314151617181920212223242526272829303132333435363738/** * * 2021-7-28 * LeetCode82 删除排序链表中的重复元素 II * **/#include&lt;iostream&gt;using namespace std;// Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;&#125;; class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode ret(0, head), *p = &amp;ret, *q; while (p -&gt;next)&#123; if (p -&gt;next-&gt;next &amp;&amp; p -&gt;next-&gt;val == p -&gt;next-&gt;next-&gt;val)&#123; q = p-&gt;next-&gt;next; while (q &amp;&amp; q-&gt;val == p-&gt;next-&gt;val)&#123; q = q-&gt;next; &#125; p-&gt;next = q; &#125;else&#123; p = p-&gt;next; &#125; &#125; return ret.next; &#125;&#125;;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/tags/Algorithms/"}]},{"title":"Data","slug":"Data","date":"2021-04-12T13:47:35.000Z","updated":"2023-06-19T13:56:15.200Z","comments":true,"path":"2021/04/12/Data/","link":"","permalink":"https://idzforjh.github.io/2021/04/12/Data/","excerpt":"","text":"科研日记概述此次实验是本人学术生涯中真正意义上的第一次实验，本markdown文档用于记录每一次的实验过程，以及解决方案和心得。源于张旭老师所提出的课题有关无线自组织网络（Ad-hoc network）中的AODV协议进行分析并改进项目，本项目由我（卜飏）作为科研实践主力，张旭老师以及其他通信相关专业同学提供理论技术支持。 目前项目暂定分为如下几步实行： 阅读论文，复现实验，基础知识积累 构建自己的模型，并对协议中部分参数进行修改并观察现象 确定结果，发表论文 ​ ——2021.4.12 修改 NS2 仿真软件安装啊，这个 主要是参照csdn论坛。我自己也是照着做的地址放在下面了： https://blog.csdn.net/qq_43715228/article/details/85057295（Ubuntu18.04.1 64位 安装ns2.35全过程–水逆选手必看！！高版本Ubuntu必看！！） 也是张旭老师推荐的，我的linux入门也是装这个玩意学会的，主要就是多敲就好。这个博客是使用的18.04.1不过我在写段话的时候已经是21年了ubuntu也不可避免的默认提供20.04版本了，所以还是要找，不过我准备送佛送到西直接把我的下载地址贴在下面吧。（希望这些不靠谱的连接都不会失效。互联网是个大海很多好东西都随着时间再也找不到了，唉…） https://releases.ubuntu.com/18.04/?_ga=2.244558597.1623985578.1617688314-1984527312.1617688314 这个是官方的下载地址，慢的话走迅雷下吧，迅雷不会用 vmware 或者 vbox不会用我就要看不起你了，所以高傲的我不想再花口水教这些很基础的东西。 em 经过我的亲生经历，20.04版本也能装ns2 但是需要换清华源，才能安装老版本的gcc（5.4最低）但是帖子里是4.8 但是 我觉得问题不大，但是但是但是（套娃开始）我在最终安装完毕后有出现 sudo su 切换成管理员模式后找不到 ns 命令的情况，还有各种奇怪的运行错误，但是我又不好判断是不是人为的，事实上直到我后来开始采集数据ns以及相关tcl文件都是用的很熟练的情况下依旧会出现人为问题。而且截止到写这段话（2020.4.12）之前我都没法解决，只能删掉重新开始但是扯远了别害怕，我的学弟们有提过一个方案就是安装老版本的 ubuntu 好像是12 版本的？还是14来着的… 但是我个人是很摈弃这个做法的，因为就缺少了很多去亲身解决linux问题的过程，这个在大三老丁开设linux课程的时候很不利（想想别人花了1个多小时还没搞定你只要半个小时，而且还有妹子来问你怎么办，嘿嘿嘿）。大概就是这样吧，慢慢来。 NS2 小工具说明NS2仿真实验——多媒体和无线网络通信（柯志亨）,详细使用说明可参考。 cbrgen软件目录位置： &#x2F;ns-allinone-2.35&#x2F;ns-2.35&#x2F;indep-utils&#x2F;cmu-scen-gen 使用方法： 1usage: cbrgen.tcl [-type cbr|tcp] [-nn nodes] [-seed seed] [-mc connections] [-rate rate] setdesk软件目录位置： &#x2F;ns-allinone-2.35&#x2F;ns-2.35&#x2F;indep-utils&#x2F;cmu-scen-gen&#x2F;setdest 使用方法： 1usage: ./setdest -v &lt;1&gt; -n &lt;nodes&gt; -p &lt;pause time&gt; -M &lt;max speed&gt; -t &lt;simulation time&gt; -x &lt;max X&gt; -y &lt;max Y&gt; 代码说明关于这点我必须要好好说说了，以前天天看笑话（第一年：这个程序怎么执行？第二年：这个函数是干嘛的？第三年：这是我写的代码？）。没想到有一天自己遇到了，重拾一年前的项目看着熟悉又陌生的代码整个人都要没了，又不好意思跟老师说（我的骄傲不允许低头！当然 问了也挺尴尬的…）。总之在此留下代码注释，这个模块应该会做很多次修改但是就不一定会在这里写了，因为要做版本控制嘛，每次更新都附上日期以及修改内容就好了一切以最终版本为参考。 adhoc.tcl好的，这个就是模拟仿真需要用到的主要tcl脚本文件了，使用方法如下： 123Usage: ns adhoc.tcl Routing_Protocol Traffic_Pattern Scene_PatternExample: ns adhoc.tcl DSDV cbr-50-10-8 scene-50-0-20 唉其实下面都已经写了但是 我还是要说一下 显得专业一点，需要&#x2F;可以修改的参数放在下面的引用里了。 12345678910111213141516171819202122232425262728293031323334if &#123;$argc !=3&#125; &#123; puts &quot;Usage: ns adhoc.tcl Routing_Protocol Traffic_Pattern Scene_Pattern&quot; puts &quot;Example:ns adhoc.tcl DSDV cbr-50-10-8 scene-50-0-20&quot; exit&#125;set par1 [lindex $argv 0]set par2 [lindex $argv 1]set par3 [lindex $argv 2]set val(chan) Channel/WirelessChannel ;# channel typeset val(prop) Propagation/TwoRayGround ;# radio-propagationmodelset val(netif) Phy/WirelessPhy ;# network interface typeset val(mac) Mac/802_11 ;# MAC typeif &#123; $par1==&quot;DSR&quot;&#125; &#123; set val(ifq) CMUPriQueue&#125; else &#123; set val(ifq) Queue/DropTail/PriQueue ;# interface queue type&#125;set val(ll) LL ;# link layer typeset val(ant) Antenna/OmniAntenna ;# antenna modelset val(ifqlen) 50 ;# max packet in ifqset val(rp) $par1 ;# routing protocolset val(x) 2000set val(y) 2000set val(seed) 0.0set val(tr) temp.trset val(nn) 10set val(cp) $par2set val(sc) $par3set val(stop) 100.0 $par1&#x3D;&#x3D;”DSR”： $符号是shell语言里的应用符代表执行变量，而其后的 DSR参数则对应你需要实验的路由协议，如 AODV 、DSDV啥的 set val(ifqlen)：这段代码我不是很清楚其定义，暂且将其理解为最大的发（数据）包数。 set val(x) 、set val(y)：不用多说，来设定 模拟环境的大小 set val(seed)：种子，对数据的影响有待考究，容我看看在说 set val(nn) ：节点数，这个一定要和cbr文件里的设定的nn（number of nodes）数量一样不然会报错，可以和scan里的不一样也就是setdest工具生成的那个文件，但是如果这么做实验数据还能不能用 我不太敢保证。 set val(stop) ：个人理解是运行时间，但我怀疑是节点的暂停等待时间（移动啥的）。 F_H_Gv3.0.tcl当当当，允许我隆重的介绍18届科研小组最重要的成果，缝合怪(F_H_G)v3.0 版本的发布（其实我那段时间有点沉迷魔兽）。当然那会我还很菜，主要工作是由网络工程（统）班的 何健翔同学创造的，我主要是负责一些修改，以及参数微调，这里选取的是第45行开始的。其实本质上这个代码就是由张旭老师的3个原始元件合并而成，算是小小的重构吧毕竟节省了很多事情。这段代码原理是使用正则表达式来匹配term.tr仿真结果文件中的数据，并对其进行汇总最后得出丢包率等等需要的信息。 1234567891011121314151617181920 if((($1==&quot;s&quot;) || ($1==&quot;f&quot;)) &amp;&amp; ($19==&quot;RTR&quot;) &amp;&amp; (($35==&quot;AODV&quot;)||($35==&quot;message&quot;))) &#123; load++; &#125; &#125;END&#123; for(packet_id = 0; packet_id &lt;= highest_packet_id; packet_id++) &#123; start=start_time[packet_id]; end=end_time[packet_id]; if(end != -1 &amp;&amp; start &lt; end) &#123; packet_duration=end - start; duration_total = duration_total + packet_duration; &#125; &#125; printf(&quot;Delay:%.4f\\n&quot;,duration_total/receives); printf(&quot;CBR_F/TCP_F Sent:%d Receive:%d, r/s Ratio:%.4f, f:%d \\n&quot;, sendLine, recvLine, (recvLine/sendLine*100),fowardLine); Normalized_load=load/recvLine_1; printf(&quot;Load:%d,N_Load:%.4f\\n&quot;,load,Normalized_load);&#125; 全代码只有一个地方需要修改： 第45行的 (($35==&quot;AODV&quot;)| 中间部分需要换成仿真时使用到的协议。 科研日志Day1实验配置： cbrgen: type nn seed mc rate cbr 80 3 10 100.0 cbr 90 3 10 100.0 cbr 100 3 10 100.0 cbr 110 3 10 100.0 cbr 120 3 10 100.0 cbr 130 3 10 100.0 cbr 140 3 10 100.0 cbr 150 3 10 100.0 cbr 160 3 10 100.0 Setdest: nn p M t x y 80 5 100 100 2000 2000 90 5 100 100 2000 2000 100 5 100 100 2000 2000 110 5 100 100 2000 2000 120 5 100 100 2000 2000 130 5 100 100 2000 2000 140 5 100 100 2000 2000 150 5 100 100 2000 2000 160 5 100 100 2000 2000 实验结果： nn Delay CBR Sent Receive r&#x2F;s Rate forward load n_load 80 0.0064 1002 1001 99.9002 0 80 0.0799 90 0.2779 277 190 68.59 258 91 0.4789 100 1.3544 501 102 20.3593 418 205 2.0098 110 0.526 629 524 81.717 519 111 0.216 120 0.5205 576 9 1.5625 50 364 40.444 130 0.8161 641 328 51.17 740 132 0.4024 140 0.5323 932 728 79.2696 773 141 0.1911 150 0.7229 228 85 32.2807 277 153 1.8 160 0.6567 256 13 5.0781 115 325 25 结果分析： 初步怀疑收发率低下是否是由转发报文太多引起，但是现象不明显还需要多试试，我准备以120n为基准尝试不同的种子（模拟随机条件）。 关于mc最大联机数问题就目前的结果来看似乎并没有太大关系，3组实验数据完全一致。","categories":[{"name":"Network engerning","slug":"Network-engerning","permalink":"https://idzforjh.github.io/categories/Network-engerning/"}],"tags":[{"name":"Ad-hoc","slug":"Ad-hoc","permalink":"https://idzforjh.github.io/tags/Ad-hoc/"}]},{"title":"Linux Notebook","slug":"Linux","date":"2021-03-30T05:24:09.000Z","updated":"2023-06-19T13:56:44.439Z","comments":true,"path":"2021/03/30/Linux/","link":"","permalink":"https://idzforjh.github.io/2021/03/30/Linux/","excerpt":"Hands on Linux operation system for Centos 8","text":"Hands on Linux operation system for Centos 8 Linux notebook for CentOS 8Linux 内核版本：version: r.x.y （2.6之前的版本号含义） ​ r：目前发布的kenel主版本 ​ x：偶数为稳定版本；奇数为开发版本 ​ y：错误修复次数 （2.6～3.0版本）： ​ y：随新版本发布而增加 ​ z：bug修复、安全更新、添加新特性和驱动次数增加 （3.0～ ）： ​ 不再使用奇偶数代表开发与稳定版本，0为默认稳定版 Shell命令基础命令1命令名称 [-选项] [参数] 区分大小写 系统关机命令 123halt //系统正常关机reboot //重新启动poweroff //系统关机后关闭电源 登陆提示信息含义： 1[root@localhost~]# root：当前用户的账号 localhost：主机名 ～：用户当前所在目录 #：root用户的命令提示符 $：普通用户的命令提示符 ls (list) 命令 1234ls -als -lls -ils -d -a：列出所有项 -l：以长格式输出文件的详细信息 -i：显示文件的索引节点号 -d：只列出目录本身的信息 man命令 1man who 查看 who命令的使用手册 date命令 显示系统当前的日期和时间 who命令 12who -rwho -q -r：显示系统当前的运行级 -q：显示登录系统的用户名称和在线总人数 cal命令 日历命令 123calcal 2019cal 8 2019 uname命令 显示当前操作系统的相关信息 1234uname -runame -nuname -vuname -i -r：显示操作系统的发行版本号 -m：显示所用机器类型 -v：显示操作系统的版本 -i：显示所需硬件平台 wc命令 wc [lw] [-c] 文件名 输出格式：行数、字数、字节数、文件名 12wc -l f1wc deom demo1 demo2 统计文件f1的行数 统计三个文件的信息 扩充通配符 *：表示任意长度的任何字符 ?：表示任意的一个字符 [] - !：[]、-：表示指定一个符号的取值范围，使用!表示相反含义 特殊符号 ;：隔开多条命令，使他们可以连续执行 &amp;：指令当前命令在后台运行 \\：转译符号 输入、输出重定向 输出重定向和附加输出重定向 输出重定向：命令 &gt; 重定向文件（覆盖原文件） 附加输出重定向： 命令 &gt;&gt; 重定向文件（在指定文件末尾追加命令效果） 12date &gt; recordwho &gt;&gt; record cat命令 1cat [选项] 文件名 建立小型文件 123cat &gt; 文件名echo cat1 is not a cat1！# ctrl + d 关闭 文件合并 1cat file1 file2 &gt; file3 管道 |多命令集合，完成复杂功能 more命令 分屏显示文件内容 1ls -al /erc|more vim 文本编辑器编译器自动： 1vim [选项][文件名] 命令模式： 123456i：从当前光标位开始输入字符I：在当前行首，开始输入字符a：从当前光标的下一个位置开始输入字符A：移动到当前行尾，开始输入字符o：光标所在行下，插入一行O：光标所在行上，插入一行 gcc编译器1gcc [选项] [文件名] 源代码文件要求带扩展名（*.c） 可执行代码默认保存在 a.out文件中 常用选项： 1234-ansi：只支持ANSI标准的c语法-c：生成目标文件（*.o）-o [file name]：指定可以执行文件名-O[level]：进行优化 文件操作touch创建文件 1touch [文件/目录路径] rm删除 12rm -frm -r -r 递归删除目录下所有文件 -rf 不提示直接删除所有文件 文件属性 由 权限、链接数、文件属主、文件属组、文件大小、创建时间\\最近修改时间 组成 find查找指定文件 1find [路径][表达式] 目录操作1234567mkdir [catalog name] #创建cd [catalog name] #进入rmdir [catalog name] #删除pwd #显示ls #列出内容mv [路径] [路径] #移动 cp [路径] [路径] #复制 cp命令 123-b #若有同名文件，先备份-r #递归复制，保留源目录结构-a #复制目录 mv命令 12-b #若有同名文件，先备份 -f #强制覆盖 权限Linux 用户分类： 文件所有者(owner) 同组用户(group) 其他用户(other) 访问权限：ls -l 查看文件权限 读取权限 写入权限 文件：修改文件内容的权限 目录：删除、添加和重命名目录内文件的权限 执行权限 访问权限表示法： 字幕表示法 r：读 w：写 x：可执行或查找 -：无权限 数字表示法 相应权限位，有权限为1；无权限为0（八进制） 文件属主：读写权限 7（111） 同组用户：执行权限 5（101） 其他用户：无权限 4（100） 权限管理1234ls -l #查看权限chmod #修改访问权限chown #修改文件所有者、所属组群chgrp #修改文件所属组群 chmod 命令 12345chmod [字母模式] [文件名]chmod [数字模式] [文件名]chmod g+x, o-r [file name]chmod 670 [file name] chown 命令 12chown [user] [file name] #修改文件所有者chown [user:user] [file name] #修改文件所有者和组群 chgrp 命令 1chgrp [group name] [file name] #修改所属组","categories":[{"name":"Linux","slug":"Linux","permalink":"https://idzforjh.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://idzforjh.github.io/tags/Linux/"}]},{"title":"Algorithm","slug":"algorithm","date":"2021-01-09T13:13:48.000Z","updated":"2021-01-09T13:19:15.000Z","comments":true,"path":"2021/01/09/algorithm/","link":"","permalink":"https://idzforjh.github.io/2021/01/09/algorithm/","excerpt":"","text":"","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://idzforjh.github.io/tags/Algorithm/"}]},{"title":"","slug":"OpenCV 树莓派部署","date":"2020-12-19T05:53:03.000Z","updated":"2020-12-20T02:45:38.000Z","comments":true,"path":"2020/12/19/OpenCV 树莓派部署/","link":"","permalink":"https://idzforjh.github.io/2020/12/19/OpenCV%20%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2/","excerpt":"","text":"OpenCV 树莓派部署1. 刻录操作系统1.1 烧写工具下载地址https://www.balena.io/etcher/ 1.2 系统文件部署系统镜像官网 1https://openeuler.org/zh/download/ 注：需要带图形的操作系统，否则无法部署 OpenCV vandyke - securecrt 下载地址 1https://www.vandyke.com/download/securecrt/6.7/index.html 2. 系统设置连接wifi：在 root 权限下执行 1nmcli dev wifi connect SSID password PWD 其中，SSID 为上一步扫描到的可供连接的 WIFI 的 SSID，PWD 为对应 WIFI 的密码，如： 1nmcli dev wifi connect openEuler-wifi password 12345678 SecureCRT 连接系统：macOS , SecureCRT: 8.5.3 打开软件后点击 connect 按键，做出如下配置： Hostname 为 树莓派的IPv4地址 注：树莓派与电脑需在同一网段。 做完配置后点击左下脚的connect 远程连接树莓派 最后如果连接正常，状态栏左侧会显示一个绿色的对号： 2.1 修改系统磁盘默认根目录分区较小，在使用前需要对其进行扩容。 使用 fdisk -l 命令查看磁盘分区信息，结果如下： SD 卡对应盘符为 &#x2F;dev&#x2F;mmcblk0，包括 3 个分区，分别为 &#x2F;dev&#x2F;mmcblk0p1：引导分区 &#x2F;dev&#x2F;mmcblk0p2：交换分区 &#x2F;dev&#x2F;mmcblk0p3：根目录分区 这里我们需要将根目录分区 &#x2F;dev&#x2F;mmcblk0p3 进行扩容，执行如下命令，进入交互界面： 1fdisk /dev/mmcblk0 结果如下： 系统会弹出一个对话框 Command (m for help): 输入 p，查看分区信息。 记录分区 &#x2F;dev&#x2F;mmcblk0p3 的起始扇区号，即 &#x2F;dev&#x2F;mmcblk0p3 分区信息中 Start 列的值，示例中为 1593344。 随后输入 d 选择删除功能，然后输入3 表示删除第三个区域，成功后系统会提示已经完成，如下图所示： 在完成删除后，输入n 创建新的分区，此时系统会询问所要创建的分区类型，这里我们选择 输入 p 创建 primary 类型分区。然后输入3，创建序列号为3的分区，也就是之前所见过的/dev/mmcblk0p3 分区，之后系统会询问新的分区起始扇区号，也就是上文所提及的默认分区时第三扇区的起始位置，下图中为 1593344 号扇区。最后按下enter键，这里系统是默认使用最后一个扇区作为新分区的终止扇区号。 在创建完新的分区后，系统会询问你是否需要修改扇区标记，这里输入 n 拒绝，随后输入w 保存分区设置退出交互界面。 在完成分区操作后记得使用 fdisk -l 命令查看新的磁盘分区信息，以确保磁盘分区正确。 然后执行 resize2fs /dev/mmcblk0p3 命令，增大未加载的文件系统大小。 继续执行df -lh 命令查看磁盘空间信息，确保根目录分区已扩展。 注： 如果根目录分区未扩展，可执行 reboot 命令重启树莓派之后再在 root 权限下执行 resize2fs &#x2F;dev&#x2F;mmcblk0p3。 2.2 DNF 换源默认的源太慢了～～～ 2.2.1 官方源在终端输入如下命令，打开配置文件： 1vi /etc/yum.repos.d/openEuler_aarch64.repo 将以下内容添加在文件的末尾： 123456[osrepo]name=osrepobaseurl=https://repo.openeuler.org/openEuler-20.09/OS/aarch64/enabled=1gpgcheck=1gpgkey=https://repo.openeuler.org/openEuler-20.09/OS/aarch64/RPM-GPG-KEY-openEuler vim 文件的一般打开后是阅读模式，可尝试在英文输入法环境下输入几个单词，如果发现无法输入则先按下键盘上的 i 键进入编辑模式，然后输入内容。 保存文件的方法与macOS、ubuntu一样为 先按下 esc 键，然后输入 :wq 后按下 enter 回车健，保存。 2.2.2 华为源在终端输入如下命令： 1dnf install wget 之后系统会有多次询问，默认输入y 便可以了。 随后 备份 原文件夹中的文件。 2.2.2.1 Filezilla ftp client 软件下载突然多了一个小节，是因为在学长陈豪的version中原本的有一步文件替换的步骤被 优化 了，因此为了接下来的步骤，在此需要额外进行一个软件的安装。 首先当然是去官网寻找适合你系统的安装包： 1https://www.filezilla.cn/download/client 在这一步骤中，所需要用到的文件： 随后打开 FileZilla，最上方 主机 为树莓派的ip地址，用户名为 树莓派的管理员名称， 密码则是系统默认的 openeuler ，端口号为 22。完成配置后点击快速连接，随后会有一个信任报警，如果有点确定。随后连接成功如下图所示，图中左侧为系统磁盘，右侧为树莓派磁盘。 在本地磁盘上选中依赖源的 repo文件，然后右击上传到树莓派到 根目录（home）目录下。 遇到的一些问题，解决问题过程时候的截图。具体会在下面说明。 随后在树莓派到终端中执行文件迁移命令： 1rm openEuler.repo /etc/yum.repos.d/ ————————————————————————————————— Houston, we have a problem. 在换华为源的时候，陈豪学长误将原源 源文件传给我了。在进行完文件迁移后查看文件内部的时候发现这个问题，一开始是以为传输失败（因为时延问题）后来删除了原文件后再次重传发现一开始的文件就不是华为源。因此这个方法先放在这里留作参考。 ————————————————————————————————— 我们继续换源。 这次先 备份 原文件夹里的文件，其位置在 /etc/yum.repos.d/ 其实任何关于软件或系统文件的修改都最好留有至少一个备份这样在发生未知错误或意外时可以及时恢复而不至于重装系统。 然后 删除 文件夹里的文件 使用命令 rm [文件名] 之后输入命令： 1wget -O /etc/yum.repos.d/openEulerOS.repo https://mirrors.huaweicloud.com/repository/conf/openeuler_aarch64.repo 然后执行 dnf clean all 清除原有 yum 缓存 最后执行 dnf makecache 生成新的缓存 常用 DNF 指令 12345dnf repolist // 显示相应软件源的配置dnf search // 使用rpm包名称、缩写或者描述搜索需要的RPM包dnf remove // 卸载软件包以及相关的依赖软件包dnf install // 安装一个软件包及其所有未安装的依赖 2.3 编译 OpenCV 依赖库2.3.1 依赖库安装在SecureCRT软件中 右击选项卡，点击 clone in new window 可以 手工进行多线程操作。 这个环节所需要的依赖库有如下： libraw1394* make* cmake* gcc* gtk2* gtk3* gtk+* libjpeg* openjpeg* gstreamer* libmpeg* libgnomeui* gphoto2* libgphoto2* libv4l-devel* numpy* build* zlib* openssl* gl* g++* 123dnf install libraw1394* &amp;&amp; dnf install make* &amp;&amp; dnf install cmake* &amp;&amp; dnf install gcc* &amp;&amp; dnf install gtk2* &amp;&amp; dnf install gtk3* &amp;&amp; dnf install gtk+*dnf install libjpeg* &amp;&amp; dnf install openjpeg* &amp;&amp; dnf install gstreamer* &amp;&amp; dnf install libmpeg* &amp;&amp; dnf install libgnomeui* &amp;&amp; dnf install gphoto2* &amp;&amp; dnf install libgphoto2* 额外： 1dnf install lmdb* &amp;&amp; dnf install hdf5* &amp;&amp; dnf install doxygen* &amp;&amp; dnf install tbb* &amp;&amp; dnf install pylint* 使用 dnf install gcc* 即可安装 gcc 相关依赖，后续默认 y 同意。 2.3.4 编译源码安装上传所需资源包，在文件夹 openEuler_libPt.1 中 *.tar 使用 tar -xvf解压*.gz 使用 gzip-d或者 gunzip解压*.tar.gz 和 *.tgz 使用tar -xzf解压*.bz2 使用bzip2 -d或 bunzip2解压.tar.bz2 使用tar -xjf解压*.Z 使用uncompress解压*.tar.Z 使用tar -xZf解压*.rar 使用unrar e解压*.zip 使用unzip解压 123456789tar -zxf VTK-8.2.0.tar.gz tar -zxf ffmpeg-3.4.tar.gz tar -zxf &#x27;tiff-4.0.10 .tar.gz&#x27; tar -zxf yasm-1.3.0.tar.gz tar -zxf ccache-3.2.4.tar.gz tar -zxf jasper-2.0.14.tar.gz tar -zxf protobuf-all-3.14.0.tar.gz tar -xjf x264-master.tar.bz2 unzip mirrors_Distrotech-libdc1394-distrotech-libdc1394.zip 2.3.4.1 yasm-1.3.012./configuremake -j4 &amp;&amp; make install 2.3.4.2 x264-master12./configure --enable-shared --enable-picmake -j4 &amp;&amp; make install 过程：不要慌，问题“很大”，慌也没用。不如坐下来泡杯咖啡等等。 ————————————————————————————————— Houston, we have a problem. 系统突然断电，重启后 make 编译报错 查询 config.log 日志后： 解决方案：dnf -remove gcc* 然后 dnf install gcc* 解决问题 ————————————————————————————————— 2.3.4.3 libdc139412./configuremake -j4 &amp;&amp; make install 2.3.4.4 jasper-2.0.1412345cd buildcmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release -DCMAKE_SKIP_INSTALL_RPATH=YES -DJAS_ENABLE_DOC=NO -DCMAKE_INSTALL_DOCDIR=/usr/share/doc/jasper-2.0.14 ..make -j4 &amp;&amp; make install 2.3.4.5 tiff-4.0.1012/configure CFLAGS=-fPIC --enable-sharedmake -j4 &amp;&amp; make install 2.3.4.6 ccache-3.2.412./configuremake -j4 &amp;&amp; make install 2.3.4.7 VTK-8.2.01234mkdir buildcd build cmake ..make -j4 &amp;&amp; make install 2.3.4.8 ffmpeg-3.4 时间最长123./configure --enable-shared --enable-avresamplemake -j4make install 额外： glog 12345git clone https://github.com/google/glog.gittar zxvf glog-0.3.3.tar.gzmkdir build &amp;&amp; cd buildmake -j4&amp;&amp; make install gflags 12mkdir build &amp;&amp; cd buildmake -j4&amp;&amp; make install eigen 1234git clone https://gitlab.com/libeigen/eigen.gitmkdir buildcd buildmake install 2.4 OpenCV 安装","categories":[],"tags":[]},{"title":"OpenCV(II)","slug":"OpenCV(II)","date":"2020-11-29T13:22:42.000Z","updated":"2020-11-29T14:41:23.000Z","comments":true,"path":"2020/11/29/OpenCV(II)/","link":"","permalink":"https://idzforjh.github.io/2020/11/29/OpenCV(II)/","excerpt":"","text":"Image Basics​ 一切的开始：图像的基础-像素（pixel），如何通过像素生成图像，如何通过OpenCV来操控图像中的像素点。 像素的定义熟悉的可以暂时跳过这一段，主要来科普图像的组成。比如说我们常见的一个显示器的分辨率是1080p（蓝光）其标准大小为1920x1080 也就是，长：1920个像素；宽：1080个像素点。合起来总共是1920x1080&#x3D;2073600个像素点。 目前我们常见的图像都是由两个东西组成：灰度值和色彩。灰度值：0～255，其中0为黑，而255为白，中间值称为灰色。色彩：由 R(Red) G(Green) B(Blue)组成，其值也是在0～255的范围内。 坐标系图像表示为像素网格。想象我们的网格就像一张方格纸。使用此方格纸，点（0，0）对应于图像的左上角。当我们向下和向右移动时，x和y值都会增加。 源代码像素点操作： 1234567891011from __future__ import print_functionimport argparseimport cv2ap = argparse.ArgumentParser()ap.add_argument(&quot;-i&quot;, &quot;--image&quot;, required = True, help = &quot;Path to image&quot;)args = vars(ap.parse_args())image = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Original&quot;, image) 和之前一样，11行代码用来处理从命令行传进来的硬盘上的图像数据，并将数据存储为 numpy的数组形式。 OpenCV将图像存储为数组，可以将其理解为一个矩阵，只需要提供具体的x，y的值就可访问对应的像素点。得到的返回数据应该是由R, G, B三个元素组成的数组，但是OpenCV实际上是由 **蓝(B)、绿(G)、红(R)**的方式存储颜色数据，而非正常的 红、蓝、绿。 123456(b, g, r) = image[0, 0]print(&quot;Pixel at (0, 0) - Red:&#123;&#125;, Green:&#123;&#125;, Blue:&#123;&#125;&quot;.format(r, g, b))image[0, 0] = (0, 0, 255)(b, g, r) = image[0, 0]print(&quot;Pixel at (0, 0) - Red:&#123;&#125;, Green:&#123;&#125;, Blue:&#123;&#125;&quot;.format(r, g, b)) 获取位于（0，0）图像位置上的像素点信息，该像素返回的元素是以元组的形式，而且是以b, g, r的顺序从数组中获取相关色彩值，最后将他们输出到可视化界面中。 随后，操纵图像中位于坐标（0，0）的左上像素，并将其值设置为（0，0，255）。如果以RGB格式读取此像素值，则红色的值为0，绿色的值为0，蓝色的值为255，因此使其成为纯蓝色。将像素设置为红色后，获取像素值，并将其打印回控制台，以证明确实已经成功更改了像素的颜色。 借用numpy的数组切片功能访问部分图像（矩形）： 1234567corner = image[0:100, 0:100]cv2.imshow(&quot;Corner&quot;, corner)image[0:100, 0:100] = (0, 255, 0)cv2.imshow(&quot;Updated&quot;, image)cv2.waitKey(0) 四个索引： 起始y：第一个值是起始y坐标。 这是我们的数组切片将沿y轴开始的位置。在上面的示例中，我们的分片从y &#x3D; 0开始。 终点 y：就像我们提供了y的开始值一样，我们也必须提供y的结束值。当y &#x3D; 100时，我们的切片沿y轴停止。 起始x：我们必须提供的第三个值是切片的起始x坐标。为了获取图像的左上角区域，我们从x &#x3D; 0开始。 终点x：最后，我们需要提供x轴值以使切片停止。当x &#x3D; 100时我们停止。 提取目标区域后 通过调用corner显示裁剪结果。之后的代码是修改区域颜色数值设置为(0, 255, 0) 绿色。 结果输出： 12Pixel at (0, 0) - Red: 127, Green: 223, Blue: 17 Pixel at (0, 0) - Red: 255, Green: 0, Blue: 0","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://idzforjh.github.io/categories/Machine-Learning/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://idzforjh.github.io/tags/OpenCV/"}]},{"title":"OpenCV(I)","slug":"OpenCV(I)","date":"2020-11-29T12:02:31.000Z","updated":"2020-11-29T13:23:33.000Z","comments":true,"path":"2020/11/29/OpenCV(I)/","link":"","permalink":"https://idzforjh.github.io/2020/11/29/OpenCV(I)/","excerpt":"","text":"P Y T H O N A N D R E Q U I R E D PA C K A G E S123456pip install numpypip install scipypip install matplotlibpip install mahotaspip install scikit-learnpip install -U scikit-image L O A D I N G , D I S P L AY I N G , A N D S AV I N G从0开始学习OpenCV(当然得有一定的Python基础)，直接来看代码吧，新建一个load_display_save.py 12345678from __future__ import print_functionimport argparseimport cv2ap = argparse.ArgumentParser()ap.add_argument(&quot;-i&quot;, &quot;--image&quot;, required=True, help=&quot;Path to the image&quot;)args = vars(ap.parse_args()) 首先是导入所必须要的第三方库。 from __future__ import print_function 实际上在这里使用的是print()函数，而不是print语句实际上是为了兼容python3 和 python2的使用。 argparse 是为了帮助处理解析命令行参数，而cv2 很明显是为了之后的图像处理做引用。 随后5-8行代码是用来处理解析命令，--image 用来获取硬盘上的图像路径，随后将量化的图像数据存储在字典中（python本身并没有数组功能（python3.7），使用numpy可以解决）。 1234567image = cv2.imread(args[&quot;image&quot;])print(&quot;width:&#123;&#125;pixels&quot;.format(image.shape[1]))print(&quot;height:&#123;&#125;pixels&quot;.format(image.shape[0]))print(&quot;channels:&#123;&#125;&quot;.format(image.shape[2]))cv2.imshow(&quot;Image&quot;, image)cv2.waitKey(0) 现在，所选择的图片已经加载到计算机内存中了，调用cv2.imread()函数，它可以返回一个代表图像的 Numpy 数组。 随后三行代码，通过print()函数来输出（可视化）图像的信息，因为已经是数组形式的数据了所以这里可以通过调用.shape属性来输出。 最后两行，第一个用来在桌面显示我们调用的图像，imshow()方法中的&quot;Image&quot;代表输出框的名称，image 代表我们从硬盘中提取到内存中的图像映射名称，waitKey()方法用来控制输出的选项框不会立刻消失（如果没有这行代码，可能结果只会出现在一瞬间后就立马消失），”0”代表按下键盘上的任意按键来结束（关闭）这个输出框。 最后一件事就是将“处理（事实这个程序15行啥也没干…不过作为学习使用方法了）”写入到硬盘中： 1cv2.imwrite(&quot;newimage.jpg&quot;, image) 如果想调试这个项目的话需要在terminal中“手动”调试：（pycharm下方自带terminal选项卡可以很方便的使用，vs code也同理，如果需要在cmd之类的终端运行代码的话 需要cd 到代码所在目录。） 比如： 1python load_display_save.py --image ./images/trex.png","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://idzforjh.github.io/categories/Machine-Learning/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://idzforjh.github.io/tags/OpenCV/"}]},{"title":"BurpSuite","slug":"BurpSuite","date":"2020-11-08T02:15:14.000Z","updated":"2020-11-08T07:19:19.000Z","comments":true,"path":"2020/11/08/BurpSuite/","link":"","permalink":"https://idzforjh.github.io/2020/11/08/BurpSuite/","excerpt":"Burp Suit(A.K.A Burp) 一款Web安全领域跨平台工具，基于Java开发。集成了Proxy、Spider、Scanner、Intruder、Repeater等常见Web漏洞模块。","text":"Burp Suit(A.K.A Burp) 一款Web安全领域跨平台工具，基于Java开发。集成了Proxy、Spider、Scanner、Intruder、Repeater等常见Web漏洞模块。 工具安装以及使用Burp Suite1. Proxy 代理模块代理模块是 Brup 的核心模块，也是我们使用最多的一个模块，主要用来截获并修改浏览器、手机App 等客户端的HTTP&#x2F;HTTPS包。 首先设置代理端口。 在Burp Suit软件中依次选择Proxuy - Options - Proxy Listeners - Add 增加代理 在Bind to port栏中填写侦听端口，这里以8080为例。 如果是在本机使用则将 Bind to address 设置为 Loopback only; 如果是在局域网内的设备使用代理则选择 All interfaces。 随后在火狐浏览器中添加代理插件 随后选择添加代理（右上角插件小狐狸，单击），代理IP为上一步所选的 地址，端口为8080。设置完成后就可以通过Burp代理来抓取IE数据包了。 接下来，在Proxy - Intercept 选项卡下设置 Intercept is on，如果设置 off，则不会拦截数据包，而是会在 HTTP history 中记录该请求。 随后打开插件，选择Burpsuit_test。然后访问一个网址，但此时浏览器会报错，原因是缺少安全证书。 通过浏览器访问 https://burp 选择右上角的 CA Certificate 下载证书。 在火狐浏览器中选择 首选项-隐私与安全-证书 中查看证书选项。 点击导入证书，选择我们刚刚下载好的证书导入到浏览器中，并选择全部信任。 2.Repeater 重放模块在需要手工测试HTTP Header中的 Cookie 或 User-Agent 等浏览器不可修改的字段是否存在注入点，以及需要发现复杂的POST数据包是否存在SSRF时，一般需要用到Repeater模块。 在Proxy模块中单击右键（Ctrl+r）就可以将截获的数据发送到Repeater模块。 在模块中，左侧为要发送的原始HTTP请求，右侧为服务器返回的数据。在左侧可以方便的修改将要发送的数据包，用于手工测试 Payload 等操作，修改完成后点击Go按钮，即可在右侧收到服务器的响应 Headers模块中可以方便、快捷地修改HTTP头部内容，有时会遇到检查IP的题目，此时可以添加X-Forwarded-Fro | X-Real-IP等HTTP头尝试绕过。 3.Intruder暴力破解模块","categories":[{"name":"Web of CTF","slug":"Web-of-CTF","permalink":"https://idzforjh.github.io/categories/Web-of-CTF/"}],"tags":[{"name":"Kali","slug":"Kali","permalink":"https://idzforjh.github.io/tags/Kali/"}]},{"title":"Screeps","slug":"Screeps","date":"2020-10-25T07:21:29.000Z","updated":"2020-11-09T08:13:22.000Z","comments":true,"path":"2020/10/25/Screeps/","link":"","permalink":"https://idzforjh.github.io/2020/10/25/Screeps/","excerpt":"Screeps-面向程序员的策略游戏","text":"Screeps-面向程序员的策略游戏 创建工人，其具有 work carry move等三种属性1Game.spawns[&#x27;Spawn1&#x27;].spawnCreep( [WORK, CARRY, MOVE], &#x27;Harvester1&#x27; ); 让工人执行最基本的挖矿脚本1234567module.exports.loop = function () &#123; var creep = Game.creeps[&#x27;Harvester1&#x27;]; var sources = creep.room.find(FIND_SOURCES); if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123; creep.moveTo(sources[0]); &#125;&#125; Game.creeps[ worker_name ] 获取需要被控制的 creep creep.room.find find 通过 room来调用 creep.harvest(sources[0]) == ERR_NOT_IN_RANGE (sources是一个数组并不是对象) ERR_NOT_IN_RANGE 目标距离 creep 太远 （注：soucre 似乎是第一个资源点的距离（相对creep）） 采矿执行完毕，返回基地123456789101112131415module.exports.loop = function () &#123; var creep = Game.creeps[&#x27;Harvester1&#x27;]; if(creep.store.getFreeCapacity() &gt; 0) &#123; var sources = creep.room.find(FIND_SOURCES); if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123; creep.moveTo(sources[0]); &#125; &#125; else &#123; if( creep.transfer(Game.spawns[&#x27;Spawn1&#x27;], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE ) &#123; creep.moveTo(Game.spawns[&#x27;Spawn1&#x27;]); &#125; &#125;&#125; if(creep.store.getFreeCapacity() &gt; 0) : .store 代表其存储中的资源对象 .getFreeCapacity() 方法 返回剩余可用容量 creep.transfer(Game.spawns[&#39;Spawn1&#39;], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE .transfer(target, resourcetype, [amount]（可选）) 将资源从该creep转移至其他对象，目标必须在紧邻creep的正方形区域中 遍历所有的 creeps 执行挖矿代码1234567891011121314151617module.exports.loop = function () &#123; for(var name in Game.creeps) &#123; var creep = Game.creeps[name]; if(creep.store.getFreeCapacity() &gt; 0) &#123; var sources = creep.room.find(FIND_SOURCES); if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123; creep.moveTo(sources[0]); &#125; &#125; else &#123; if(creep.transfer(Game.spawns[&#x27;Spawn1&#x27;], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) &#123; creep.moveTo(Game.spawns[&#x27;Spawn1&#x27;]); &#125; &#125; &#125;&#125; 模块 左下角新建模块（函数） 固定模版格式 run：function()&#123;&#125; 123456789var roleHarvester = require(&#x27;role.harvester&#x27;);module.exports.loop = function () &#123; for(var name in Game.creeps) &#123; var creep = Game.creeps[name]; roleHarvester.run(creep); &#125;&#125; var roleHarvester = require(&#39;role.harvester&#39;); 模块引用 roleHarvester.run(creep); 调用 模块 里的函数方法","categories":[{"name":"Queen`s Gambit","slug":"Queen-s-Gambit","permalink":"https://idzforjh.github.io/categories/Queen-s-Gambit/"}],"tags":[{"name":"Screeps","slug":"Screeps","permalink":"https://idzforjh.github.io/tags/Screeps/"}]},{"title":"JavaScript 基础（一）","slug":"JavaScript","date":"2020-10-14T12:31:04.000Z","updated":"2020-12-24T07:55:08.000Z","comments":true,"path":"2020/10/14/JavaScript/","link":"","permalink":"https://idzforjh.github.io/2020/10/14/JavaScript/","excerpt":"JavaScript 简单来说，就是一种专为 与网页交互 而设计的脚本语言。","text":"JavaScript 简单来说，就是一种专为 与网页交互 而设计的脚本语言。 JavaScript 由三部分组成： 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） 核心（ECMAScript）核心（ECMAScript）定义了 JavaScript的基本组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 文档对象模型（DOM）获取所写的所有 HTML标签，并给标签添加 或 删除样式，同时也可以给标签添加事件（.i.e 点击、拖动） 功能的实现基于以下接口： DOM 遍历和范围：可以找到页面中所有的标签； DOM 事件：例如给某个图片添加拖动事件，使图片可以随意拖动； DOM 样式：可以改变页面中所有元素的样式（.e.g 更改某一段文字的颜色） 浏览器对象模型（BOM）BOM 只会处理与浏览器相关的对象： 弹出新窗口功能 移动、缩放、关闭浏览器窗口的功能 给用户提供显示器分辨率的功能 提供浏览器信息 JavaScript 书写位置与 CSS 相似，分为 HTML的 内部 与 外部 JavaScript 在 HTML 的内部&lt;script&gt;&lt;/script&gt; 标签可以将 JavaScript 代码嵌入到HTML内部，方式如下： 12345678// script标签嵌入JavaScript代码&lt;script&gt; // JavaScript代码 let name = &quot;Bob&quot;; function()&#123; console.log(&quot;我的名字叫：&quot;+name); &#125;&lt;/script&gt; 在实际生活中会遇到&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;这种类型的script标签。其中type=&quot;text/javascript&quot;代表文档类型是javascript类型，字符编码解码的方式是utf-8 script标签在HTML文件中的位置一种书写规范，即body标签的内部，并且保证其是在末尾，如下代码所示： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 正常的html标签一定要写在script标签的前面 --&gt; &lt;div&gt;&lt;/div&gt; &lt;!-- 在body标签的内部并在末尾 --&gt; &lt;script&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; script 标签在 HTML文件中的位置很随意理论上哪里都可以，但是DOM元素会收到script标签位置的影响，可能会出现意想不到的报错。 Jacascript 在 HTML 的内部引入 script 标签，与 CSS 不一样的是多了一个 src 参数，引入方式如下： 1&lt;script src=&#x27;index.js&#x27;&gt;&lt;/script&gt; 标签引入书写方式与内部书写方式位置一致，都是在body标签的末尾。 JavaScript注释JavaScript 注释包括单行注释和块级注释 单行注释1// 单行注释 块级注释1234/* * 注释 * 注释 */ 字符串单引号(‘’) | 双引号(“”) 注：输入引号的时候，一定要切换为英文输入法。 中文添加引号下面两种都是字符串： 12345// 双引号 因为格式化的问题，必须加\\，大家忽略\\，就当&quot;字符串&quot;看待即可\\&quot;字符串\\&quot;;// 单引号&#x27;字符串&#x27;; 英文添加引号下面两种都是字符串： 12345// 双引号\\&quot;Tom\\&quot;;// 单引号&#x27;Tom&#x27;;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://idzforjh.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"ThreadPool（线程池）","slug":"ThreadPool","date":"2020-10-10T04:39:20.000Z","updated":"2020-10-12T14:50:17.000Z","comments":true,"path":"2020/10/10/ThreadPool/","link":"","permalink":"https://idzforjh.github.io/2020/10/10/ThreadPool/","excerpt":"​ 线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。","text":"​ 线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。 ​ 在 Java 中，如果每个请求到达就创建一个新的线程，其开销是十分巨大的。在实际使用的过程中，服务器要在创建和销毁线程上话费的时间和消耗的系统资源都相当的大，甚至可能要比在处理实际的用户请求时间的时间和资源要多的多。 ​ 如果我们在一个JAM里创建过多的进程，会使系统由于过度消耗内存 或 “切换过度” 而导致系统资源不足。因此需要“池化资源”来减少创建和销毁线程的次数。一个简单的线程池至少应包含：线程池管理、工作线程、任务队列、任务接口等部分。 线程池管理器：创建、销毁并管理线程池，将工作线程放入线程池中。 工作线程：一个可循环执行任务的线程，在没有任务时进行等待。 任务队列：一种缓冲机制，将没有处理的任务放在任务队列中。 任务接口：每个任务务必实现的借口，主要用来规定任务的入口、任务执行完毕后的收尾工作、任务执行状态等等，工作线程通过该接口调度任务执行。 注：线程池主要用来解决线程生命周期开销问题和资源不足问题。 newCachedTreadPool 创建可缓存线程池，如果线程池长度超过处理需要可回收空闲线程，若无线程可回收则新建线程。此线程池不会对线程大小做限制，其池大小完全依赖于操作系统能够创建的最大线程大小。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newSingleThreadExecutor 创建一个单线程化的线程池，只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序（FIFO、LIFO、优先级）来执行。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 可缓存线程池 Java 提供了 Executors 工厂类，来创建线程池。(i.e. Executors.newXXX 创建) newCachedThreadPool 是 Executors 工厂类的一个静态函数，用来创建一个可以无限扩大的线程池。 1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolCached &#123; private static final ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); public stati c void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; final int index = i; cachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(index); &#125; &#125;); &#125; &#125;&#125; cachedThreadPool 是线程池，因为线程是可以 重用 的，一般都定义为静态成员变量。 为了防止 cachedThreadPool 变量重新被赋值需要使用 final 修饰符。 Runnable 实现接口放入线程池后会被自动调度，启动线程不需要再使用 start() 方法。 上述示例中 new Runnable() &#123;... ...&#125; 是匿名类（i.e. 接口不可直接实例化，所以匿名类 实现了接口实例化但是没有 定义具体的类名，所以被称之为匿名类。） CachedThreadPool 可缓存线程池会优先重用空闲线程池，但由于其原理可以”无限“扩大，线程数可以随意增加，因此较多使用在处理执行时间比较小的任务。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://idzforjh.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Multithreading Pt.2 （多线程）","slug":"Multithreading Pt.2（多线程)","date":"2020-10-09T11:55:30.000Z","updated":"2020-10-25T09:05:29.000Z","comments":true,"path":"2020/10/09/Multithreading Pt.2（多线程)/","link":"","permalink":"https://idzforjh.github.io/2020/10/09/Multithreading%20Pt.2%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B)/","excerpt":"线程安全；由于一般情况下线程的执行顺序充满随机性，输出的结果往往与预计的相差甚远，这种情况就是线程的安全问题。 非线程安全：多个线程对同一个对象中的同一个实例变量进行操作时会出现 值 被更改或 值 不同步的情况，进而影响程序的执行流程。","text":"线程安全；由于一般情况下线程的执行顺序充满随机性，输出的结果往往与预计的相差甚远，这种情况就是线程的安全问题。 非线程安全：多个线程对同一个对象中的同一个实例变量进行操作时会出现 值 被更改或 值 不同步的情况，进而影响程序的执行流程。 解决线程安全问题使用 synchronized 关键字修改线程内的方法，使其保证调用执行顺序，保证线程安全。 12345678910111213141516public class Addition implements Runnable &#123; private int count; public Addition(int count) &#123; this.count = count; &#125; @Override public synchronized void run() &#123; while (count &gt; 0) &#123; System.out.println(Thread.currentThread().getId() + &quot; 计算：count=&quot; + count); count--; &#125; &#125;&#125; 对 run() 方法添加了 synchronized 关键字，当一个线程调用 run 前，会先判断有没有被上锁，如果上锁说明有其他线程正在调用 该方法，必须等其他线程对 run 方法调用结束后才可以执行方法。 synchronized 关键字可以将任意对象、方法、代码块 上锁，我们将加锁的代码称之为 互斥区 或 临界区 123456789@Overridepublic void run() &#123; synchronized (this) &#123; while (count &gt; 0) &#123; System.out.println(Thread.currentThread().getId() + &quot; 计算：count=&quot; + count); count--; &#125; &#125;&#125; 注：网络编程中每个客户端的连接请求在服务端都需要启动一个线程响应，如果出现线程安全问题就会出现各种各样莫名其妙的问题。 多线程的核心方法sleep(long millis):类方法（使用 关键词static 修饰，也叫静态方法），在指定的毫秒数内让当前正在执行的线程休眠（暂停执行） 12345try &#123; Thread.sleep(500);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; jion():实例方法，启动线程后可以直接调用（等待该线程（子线程）终止，子线程调用join()方法的语句后面的代码，只有等到子线程结束了才能执行。 12345678910111213141516171819202122public class AdditionTest &#123; public static void main(String[] args) &#123; Addition add = new Addition(3); Thread threadA = new Thread(add); Thread threadB = new Thread(add); Thread threadC = new Thread(add); try &#123; threadA.start(); threadA.join(); threadB.start(); threadB.join(); threadC.start(); threadC.join(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;that&#x27;s the end.&quot;); &#125;&#125; 示例程序较为简单，调用 System.out.println 输出。实际上在输出信息的时候有可能依赖前面线程的 执行结果 或 输出信息，在这种情况下由于线程不一定会执行完毕但是代码已经接着向下继续执行了，所以无法得到需要的线程执行结果。 因此调用 join() 方法，后面的代码不会立刻执行，必须等子线程结束，所以该方法可以确保子线程能执行完毕，从而保证 System.out.println 可以从 对象 实例中获取到正确的数据。 适用场景： 后续代码需要依赖父线程的执行结果，使用 join 方法来确保线程完整执行。 复杂、执行时间较长的线程，使用 join 方法来等待线程执行完毕。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://idzforjh.github.io/categories/Java-Web/"}],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Pseudo-element（伪元素）","slug":"Pseudo-element（伪元素）","date":"2020-10-03T15:27:17.000Z","updated":"2020-10-09T11:03:54.000Z","comments":true,"path":"2020/10/03/Pseudo-element（伪元素）/","link":"","permalink":"https://idzforjh.github.io/2020/10/03/Pseudo-element%EF%BC%88%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%89/","excerpt":"In CSS, a pseudo-element selector applies styles to parts of your document content in scenarios where there isn’t a specific HTML element to select. For example, rather than putting the first letter of each paragraph in its own element, you can style them all with p::first-letter.","text":"In CSS, a pseudo-element selector applies styles to parts of your document content in scenarios where there isn’t a specific HTML element to select. For example, rather than putting the first letter of each paragraph in its own element, you can style them all with p::first-letter. CSS 伪元素网页中常见头部布局： 常规 CSS 中的代码如下： 1&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;&lt;span class=&quot;words&quot;&gt;主页&lt;/span&gt; 1234567891011121314.icon &#123; display: inline-block; width: 24px; height: 24px; background: url(https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-2-HTML-CSS/1.2/source/first-page.png) no-repeat center; background-size: contain; vertical-align: top; margin-right: 8px;&#125;.words &#123; font-size: 18px; line-height: 24px;&#125; 此时我们可以使用一种更好的方法来完成上述实例：伪元素。 利用 css 代码在标签内部的前面 或 后面添加一个行内元素，可以理解为span ::before ::after语法： 1234567891011/* before */选择器::before&#123; /* 使用空白符号占位 */ content: &#x27;&#x27;;&#125;/* after */选择器::after&#123; /* 使用空白符号占位 */ content: &#x27;&#x27;;&#125; 以上述代码为例，使用伪元素重构代码： 1&lt;span&gt;主页&lt;/span&gt; 去除 类名为 icon 的 span 标签 1234567891011/* 在span之前添加行内元素 */span::before &#123; content: &#x27;&#x27;; /* 将添加的行内元素定位，并设置大小、背景 */ position: absolute; left: 0px; width: 24px; height: 24px; background: url(https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-2-HTML-CSS/1.2/source/first-page.png) no-repeat center; background-size: contain;&#125; display 案例：网页中用来切换元素的小圆点： 将其放大后为： 使用伪元素代码： 1&lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; 123456789101112131415161718192021.circle &#123; box-sizing: border-box; width: 200px; height: 200px; margin: 20px auto; border-radius: 50%; background: #9995A5; /* 使用padding让子元素居中 */ padding: 30px; border: 10px solid #8E8A97;&#125;.circle::before&#123; content: &#x27;&#x27;; /* 将添加的行内元素转成块元素 */ display: block; width: 120px; height: 120px; border-radius: 50%; background: #666278;&#125; 伪元素中 ::before 和 ::after用法一样，当需要在第二个行内元素时使用 ::after。 作业：实现高亮部分页面： 使用 伪元素 实现切换： 左右箭头使用 ::before 和 ::after 制作盒子，使用背景图填充箭头，再固定位置 小圆点使用ul和li组合创建 5 个外圆，然后给li添加::before并将其修改成圆形，居中在大圆里 源码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;banner&quot;&gt; &lt;!--可以使用列表完成小圆点的绘制，注意清除列表样式--&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class=&quot;third&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273* &#123; margin: 0px; padding: 0px;&#125;ul,li&#123; /*格式清除*/ list-style: none;&#125;.banner &#123; position: relative; width: 850px; height: 394px; background: url(./images/banner.png) no-repeat center; background-size: contain;&#125;.banner::before &#123; /*在这里使用伪元素完成左箭头*/ content: url(./images/left.png); position: absolute; left: 10px; top: 180px;&#125;.banner::after &#123; /*在这里使用伪元素完成右箭头*/ content: url(./images/right.png); position: absolute; right: 10px; top: 180px;&#125;ul&#123; position: absolute; bottom: 20px; right: 30px;&#125;ul&gt;li&#123; float: left; box-sizing: border-box; width: 8px; height: 8px; margin-left: 8px; border-radius: 50%; background: #9995A5; border: 1px solid #8E8A97; padding: 1px;&#125;ul&gt;li.li-last&#123; margin-right: 0px;&#125;ul&gt;li::before&#123; content: &#x27;&#x27;; display: block; width: 4px; height: 4px; background: #666278; border-radius: 50%;&#125;ul&gt;li.third&#123; background: #D6D6D6;&#125;ul&gt;li.third::before&#123; background: #D6D6D6;&#125; 清除浮动浮动带来的问题：实例： 子元素设置高度，父元素的高度由子元素撑起来以达到父元素适应的效果 12345&lt;div class=&quot;father-one&quot;&gt; &lt;div class=&quot;son-one&quot;&gt;son-one&lt;/div&gt; &lt;div class=&quot;son-two&quot;&gt;son-two&lt;/div&gt; &lt;div class=&quot;son-three&quot;&gt;son-three&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.father-one &#123; border: 2px solid #8E8A97; text-align: center;&#125;.son-one &#123; line-height: 50px; background-color: #00FFFF;&#125;.son-two &#123; line-height: 100px; background-color: #00BFFF;&#125;.son-three &#123; line-height: 50px; background-color: #00FFFF;&#125; 影响父亲元素的兄弟元素布局： 在父元素.father-one后添加一个兄弟元素后将所有子元素都浮动 12&lt;!-- 添加father-one的兄弟元素 --&gt;&lt;div class=&quot;father-two&quot;&gt;&lt;/div&gt; 123456789101112131415161718192021.son-one&#123; /* 浮动后的元素宽度默认和它内容的宽度一致，即和文字的宽度一致。 这里为了美观，设置一个自定义宽度*/ width:33.3%; float:left;&#125;.son-two&#123; width:33.3%; float:left;&#125;.son-three&#123; width:33.3%; float:left;&#125;.father-two&#123; height: 150px; background-color: #CACACA;&#125; 效果如上图所示，（红色线部分）兄弟元素渗透到父元素中，理想情况应如下： 所以需要&#96;&#96;清除浮动&#96;，让父元素包住浮动的子元素。 清除浮动 CSS源码12345.clearfix::after&#123; content: &#x27;&#x27;; display: block; clear: both;&#125; 123456&lt;!-- 添加清除浮动类名 --&gt;&lt;div class=&quot;father-one clearfix&quot;&gt; &lt;div class=&quot;son-one&quot;&gt;son-one&lt;/div&gt; &lt;div class=&quot;son-two&quot;&gt;son-two&lt;/div&gt; &lt;div class=&quot;son-three&quot;&gt;son-three&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://idzforjh.github.io/categories/Java-Web/"}],"tags":[{"name":"CSS 3","slug":"CSS-3","permalink":"https://idzforjh.github.io/tags/CSS-3/"}]},{"title":"初识 HTML5","slug":"HTML5","date":"2020-10-03T13:58:14.000Z","updated":"2020-10-03T15:00:58.000Z","comments":true,"path":"2020/10/03/HTML5/","link":"","permalink":"https://idzforjh.github.io/2020/10/03/HTML5/","excerpt":"Upgrade Complete！ HTML的升级版，更多的功能，更丰富的属性。","text":"Upgrade Complete！ HTML的升级版，更多的功能，更丰富的属性。 语义化标签基础语义： 123&lt;p&gt;&lt;/p&gt; 段落&lt;h1&gt;&lt;/h1&gt; 一级标题&lt;li&gt;&lt;/li&gt; 列表 赋予标签的意义和作用 HTML 5 中的语义化标签：下图布局所涉及的语义化标签基本涵盖了常用的所有语义化标签： 1234567891011121314&lt;!-- 头部 --&gt;&lt;header&gt;header&lt;/header&gt;&lt;!-- 主体 --&gt;&lt;main&gt; &lt;!-- 导航 --&gt; &lt;nav&gt;nav&lt;/nav&gt; &lt;!-- 区块 --&gt; &lt;section&gt;section&lt;/section&gt; &lt;section&gt;section&lt;/section&gt;&lt;/main&gt;&lt;!-- 侧边栏 --&gt;&lt;aside&gt;&lt;/aside&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt; 语义化标签使用场景头部：&lt;header&gt;&lt;/header&gt;用于展示介绍性内容，通常包含一组介绍&#x2F;辅助性的导航元素。 主体：&lt;main&gt;&lt;/main&gt;页面主体内容区域 底部：&lt;footer&gt;&lt;/footer&gt;页面页脚部分的版权数据、文档相关链接等信息 导航：&lt;nav&gt;&lt;/nav&gt;定义文档或页面的导航。 侧边栏：&lt;aside&gt;&lt;/aside&gt; 区域块：&lt;section&gt;&lt;/section&gt;文档中的节，更接近 div的语义，在页面中开辟一块空间。","categories":[],"tags":[{"name":"HTML 5","slug":"HTML-5","permalink":"https://idzforjh.github.io/tags/HTML-5/"}]},{"title":"Multithreading Pt.1（多线程）","slug":"Multithreading Pt.1（多线程）","date":"2020-10-02T14:34:39.000Z","updated":"2020-10-09T11:57:51.000Z","comments":true,"path":"2020/10/02/Multithreading Pt.1（多线程）/","link":"","permalink":"https://idzforjh.github.io/2020/10/02/Multithreading%20Pt.1%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/","excerpt":"​ 多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。","text":"​ 多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。 操作系统原理： 进程：进程是程序的一次执行；进程是一个程序及其数据在处理机上顺序执行时所发生的活动；进程是系统进行资源分配和调度的一个独立单位。 线程：不能独立的存在，必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才结束。 Thread 类继承 Thread 类定义多线程程序，缺点十分明显，由于Java是单继承的，只允许继承一个类所以变相的限制了程序的可拓展性。 继承 java.lang.Thread 类 1234567891011121314151617181920212223242526public class ThreadTest &#123; public static void main(String[] args) &#123; ThreadTest test = new ThreadTest(); MyThread thread1 = test.new MyThread(); thread1.setName(&quot;MyThread-1&quot;); MyThread thread2 = test.new MyThread(); thread2.setName(&quot;MyThread-2&quot;); thread1.start(); thread2.start(); &#125; class MyThread extends Thread &#123; @Override public void run() &#123; try &#123; System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot; 进入睡眠状态&quot;); Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot; 睡眠结束&quot;); &#125; &#125;&#125; 实例代码运行后输出结果为： 1234线程 MyThread-1 进入睡眠状态线程 MyThread-2 进入睡眠状态线程 MyThread-1 睡眠结束线程 MyThread-2 睡眠结束 多次运行后有可能得到： 1234线程 MyThread-1 进入睡眠状态线程 MyThread-2 进入睡眠状态线程 MyThread-2 睡眠结束线程 MyThread-1 睡眠结束 线程的执行顺序不是固定的，每次运行的结果都不一定相同，输出的顺序也不完全一致，且与代码调用顺序不完全一致。 原因： start() 方法： 用来启动一个线程，当调用 start 方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中会为线程分配资源。 run() 方法： 此方法不需要用户调用，当通过 start 方法启动一个线程后，线程获得了 CPU 执行时间，便会进入 run 方法来执行具体的任务 继承 Thread 类必须重写 run 方法，定义具体的任务。 sleep() 方法： 线程睡眠，释放 CPU 资源，语法： sleep(long millis) &#x2F;&#x2F; 参数为毫秒 sleep(long millis, int nanoseconds) &#x2F;&#x2F;毫秒，纳秒 线程的运行是不受用户精确控制的，start() 只是开启一个线程，真正的运行由 CPU 决定。 Runnable 接口采用实现接口方式写程序（java.lang.Runnable）符合 高内聚低耦合 的Java设计原则 实例： 1234567891011121314151617181920212223242526public class RunnableTest implements Runnable &#123; public void run() &#123; try &#123; System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot; 进入睡眠状态&quot;); Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot; 睡眠结束&quot;); &#125; public static void main(String[] args) &#123; RunnableTest rt1 = new RunnableTest(); Thread t1 = new Thread(rt1); t1.setName(&quot;MyThread-1&quot;); RunnableTest rt2 = new RunnableTest(); Thread t2 = new Thread(rt2); t2.setName(&quot;MyThread-2&quot;); t1.start(); t2.start(); &#125;&#125; 总结： Thread.currentThread().getName() 的返回值可以取当前线程的名称，由 setName() 方法指定名称。 Thread.sleep(200); 会让线程暂停执行200毫秒，然后继续执行。 线程的执行还是需要依赖 Thread 类，通过 Runnable接口类使 Thead 类 仅成为启动一个线程的入口。 RunnableTest 负责具体的线程业务逻辑，Thread 类 负责调度线程。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://idzforjh.github.io/categories/Java-Web/"}],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Serialization","slug":"Serialization","date":"2020-09-29T07:45:57.000Z","updated":"2020-10-01T11:43:38.000Z","comments":true,"path":"2020/09/29/Serialization/","link":"","permalink":"https://idzforjh.github.io/2020/09/29/Serialization/","excerpt":"​ 把一个Java对象写入到硬盘或者传输到网路上面的其它计算机，这时我们就需要自己去通过Java把相应的对象写成转换成字节流。对于这种通用的操作，我们为什么不使用统一的格式呢？没错，这里就出现了java的序列化的概念。","text":"​ 把一个Java对象写入到硬盘或者传输到网路上面的其它计算机，这时我们就需要自己去通过Java把相应的对象写成转换成字节流。对于这种通用的操作，我们为什么不使用统一的格式呢？没错，这里就出现了java的序列化的概念。 序列化 (Serialization)序列化是将对象的数据和信息转换为可以存储或传输的形式的过程，主要有以下几种情况： 当内存中的对象需要保存到一个文件中、数据库、缓存中时候； 当对象需要传输的时候。 实现 Serialization 接口对象实现了 Serialization 接口，就表示其可以被序列化。 Serialization接口是一个标记接口，也叫空接口。其内部没有任何方法，所以实现了接口也不需要实现方法。 12345678import java.io.Serializable;public class Building implements Serializable &#123; // 自定义serialVersionUID private static final long serialVersionUID = 8735132092273200831L; private String name; private String address; 如上代码是一个需要被序列化的例子。其中 serialVersionUID 主要是序列化和反序列化过程中，验证版本用的。 当对象序列化后，如果对其进行修改（新增&#x2F;删除 属性操作）则再进行反序列化后就会失败，因为对象与类的定义不一致了。为了避免这种情况给 serialVersionUID 进行赋值使对象无论发生了什么变化都能正确反序列化。 自动生成 serialVersionUID各个IDE操作方法不同，但现在的大部分都自带此功能，在此不做详细赘述。 JSONJSON(JavaScript Object Notation, JS 对象简谱) 是目前最常用的 执行 对象序列化的方式。 Json 官方 指定了一套标准，各种语言都支持这个标准，所以 Json 也能作为一种跨语言的文本数据交换格式。 必须是 对象： 1&#123; &#125; 或 数组: 1[ ] JSON 语法规则： 数据用 名称：值（也称键值对） 名称（键）必须是字符串 多条数据之间，用逗号 “,” 分隔 JSON 数值类型： 数字（整数、浮点数） 字符串（” “） 逻辑值（true 或 false） 数组（ “[ ]”） 对象（”{ }”） null 范例： 123456789101112&#123; &quot;name&quot;: &quot;韦小宝&quot;, &quot;age&quot;: 26, &quot;height&quot;: 182.4, &quot;birthday&quot;: &quot;1670-7-28&quot;, &quot;isRich&quot;: true, &quot;wifes&quot;: [&quot;阿珂&quot;, &quot;双儿&quot;, &quot;建宁公主&quot;, &quot;苏荃&quot;, &quot;沐剑屏&quot;, &quot;曾柔&quot;, &quot;方怡&quot;], &quot;firstMaster&quot;: &#123; &quot;name&quot;: &quot;陈近南&quot;, &quot;birthday&quot;: &quot;1634-12-1&quot; &#125;&#125; FastJSON – Java使用 FastJSON 来操作 JSON 以及完成对象的序列化操作。 对象序列化：本地IDE环境需在编码前引入依赖： 123456&lt;!-- 在下列地址查询最新的版本：https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; ​ 避免使用 Beta 版本和 Alpha 版本。 使用 FastJSON 打印对象： 12345678public static void main(String[] args) &#123; Building b = new Building(); b.setName(&quot;创业大厦&quot;); ... ... String content = JSON.toJSONString(b); System.out.println(content);&#125; 主要是 JSON.toJSONString( ) 方法，将对象序列化。 反序列化与序列化一样使用 FastJSON 库。 反序列化代码: 12345678910111213Building b = new Building();... ... String content = JSON.toJSONString(b); // 转换为一个具体的对象 Building b2 = JSON.parseObject(content, Building.class); String name = b2.getName(); System.out.println(name); // 特殊情况下，java系统里没有具体对象的 class ，可以反序列化为 Map Map bInfo = JSON.parseObject(content, Map.class); String name2 = (String) bInfo.get(&quot;name&quot;); System.out.println(name2); 反序列化时，调用： 1JSON.parseObject(content, Building.class) 第一个参数是字符串内容， 第二个参数是目标类。 把字符串转换为 Java 对象，转为具体的对象后就可以使用对象的属性和方法了，比如调用 b2.getName(); 取值。 反序列化为 MAP少数复杂的场景，程序需要把字符串转换为对象，但是系统中没有依赖具体的目标类这时可以将字符串转换为 Map 对象。 第二个参数执行 Map 为目标类即可，如上述实例锁写。 Java特点是 面向接口编程，不需关心具体是哪一种 Map （HashMap、TreeMap 等），这么做的好处是 解耦。 让系统更少的依赖其他系统代码，使其易于维护。 非全 序列化在类中做筛选，除去不需要被序列化的属性： 1234567891011public class Building implements Serializable &#123; // 自定义serialVersionUID private static final long serialVersionUID = 8735132092273200831L; // 方法一： 关键字 private transient String name; // 方法二： 注解 @JSONField(serialize=false) private String address; &#125; 常用去除不需要被序列化的属性有两种方法： 在声明字段的时候，添加一个 transient 修饰关键字，由 JDK 提供。 在字段上添加一个 @JSONField(serialize&#x3D;false) 注解，这个注解是 fastjson 库提供的。 注：只对序列化有效；反序列化时只需要 JSON 字符串有内容，都会按照规则反序列化对象并且对齐进行赋值。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://idzforjh.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Inner class","slug":"Inner class","date":"2020-09-28T10:33:38.000Z","updated":"2020-09-28T11:21:36.000Z","comments":true,"path":"2020/09/28/Inner class/","link":"","permalink":"https://idzforjh.github.io/2020/09/28/Inner%20class/","excerpt":"内部类（Inner class）是定义在另一个类中的类。有以下三点使用原因： 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。 内部类可以对同一个包中的其他类隐藏起来。 当想要定义一个回调函数且不想编写大量代码时，使用 匿名（anonymous）内部类比较便捷。","text":"内部类（Inner class）是定义在另一个类中的类。有以下三点使用原因： 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。 内部类可以对同一个包中的其他类隐藏起来。 当想要定义一个回调函数且不想编写大量代码时，使用 匿名（anonymous）内部类比较便捷。 Inner class 内部类内部类的语法比较复杂，先从简单语法开始讲起： 1234567public class Outer &#123; public class InnerTool &#123; // 内部类 public int add(int a,int b)&#123; return a+b; &#125; &#125;&#125; 在上述例子中，class Outer 是 外部类， class InnerTool是内部类。如果想要调用内部类那么首先必须要实例化它且只能在 内部类中 new。 12345678public class OuterUtil &#123; public class InnerTool &#123; // 内部类 public int add(int a,int b)&#123; return a+b; &#125; &#125; private InnerTool tool = new InnerTool();&#125; UML图 内部类实现：实例化： 1234567891011public class OuterUtil &#123; public class InnerTool &#123; // 内部类 public int add(int a,int b)&#123; return a+b; &#125; &#125; private InnerTool tool = new InnerTool(); public int add(int a,int b,int c)&#123; return tool.add( tool.add(a,b) , c ); &#125;&#125; 新增一个需求，实现数字加法。","categories":[],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Exception Handing","slug":"Exception Handing","date":"2020-09-27T11:30:22.000Z","updated":"2020-09-27T13:00:36.000Z","comments":true,"path":"2020/09/27/Exception Handing/","link":"","permalink":"https://idzforjh.github.io/2020/09/27/Exception%20Handing/","excerpt":"真实的编程：Bug！Bug！Bug！","text":"真实的编程：Bug！Bug！Bug！ Exception Handing​ 在理想状态下，用户输入数据的格式永远都是正确的，选择打开的文件也一定存在，并且永远不可能出现 Bug 。在绝大多数普通人的眼里，代码似乎永远都处在这样一个理想的环境中。然而现实世界中却充满了不良的数据和带有问题的代码，现在是讨论 Java 程序设计语言处理这些问题机制的时候了。 基本概念： 编译错误： 新手常见错误，主要由代码语法错误造成。 运行错误： 比较复杂的错误，只有在代码运行后才会出现。我们将其称之为 异常 ，对异常进行处理的动作称之为 捕获 Java 异常机制例如：java.lang.NullPointerException 这是一种常见的异常，当操作的不是真正的对象而是 null 时，便会抛出 NullPointerException 所以大部分情况下异常的抛出是由系统触发的。 由于 Java 面对对象的特性，异常也可以被定义为 class 类，可以使用不同的类来表示不同的异常情况 异常捕获的流程： Java 异常类如下所示，Java 异常类的基本情况： 可以很直观的知道 异常 也属于 Java 的一个 类，所以对象具备的特性它都具备。 Java.lang 包不需要 import。 常见的异常类：IOException 操作输入流和输出流时可能会出现的异常。 ArithmeticException 数字异常，比如将整数除以0（触发异常）。 NullPointerException 空指针异常。当引用变量为Null时，试图访问对象的属性或方法就会出现这种异常： 12String d = null;System.out.println(d.length()); // 抛出NullPointerException ArrayIndexOutOfBoundsException 数组下标越界异常： 123int[] array = new int[4];array[0]=1;array[7]=1; // 抛出 ArrayIndexOutOfBoundsException ClassCastException 类型转化失败异常。 IllegalArgumentException 非常参数异常，用来检查方法参数是否合法。 异常作用域123456789101112131415161718public class ExceptionTest2 &#123; public static void main(String[] args) &#123; int len = 0; try &#123; len = getStrLength(null); &#125; catch (NullPointerException e) &#123; &#125; System.out.println(&quot;程序执行到这&quot;+len); &#125; // 获取字符串的长度 public static int getStrLength(String str) &#123; return str.length(); &#125;&#125; 变量需在块之前先定义。（Python不需要） 多异常捕获实例需求：读取文件内容将其转换为数字使用 Integer.parseInt(str) 方法： 1234567891011public class ExceptionTest3 &#123; public static void main(String[] args) &#123; int num = getInt(&quot;20&quot;); System.out.println(num); &#125; // 字符串转换为数字 public static int getInt(String str) &#123; return Integer.parseInt(str); &#125;&#125; 如果此时 getInt 方法输入参数是一个字符： 1234567891011public class ExceptionTest3 &#123; public static void main(String[] args) &#123; int num = getInt(&quot;小王&quot;); System.out.println(num); &#125; // 字符串转换为数字 public static int getInt(String str) &#123; return Integer.parseInt(str); &#125;&#125; 出现报错： 1Caused by: java.lang.NumberFormatException: For input string: &quot;小王&quot; 在没注意到的情况下，有可能会人为的转入 null 对象，导致抛出异常 NullPointException。此时可以使用多次 catch 来解决： 1234567891011121314151617public class ExceptionTest4 &#123; public static void main(String[] args) &#123; int num = 0; try &#123; num = getInt(&quot;小王&quot;); &#125; catch (NumberFormatException e) &#123; &#125; catch (NullPointerException e) &#123; &#125; System.out.println(num); &#125; // 字符串转换为数字 public static int getInt(String str) &#123; return Integer.parseInt(str); &#125;&#125; 由于 Exceptions 都是继承于 Exception 类，所以可以直接用一个 Exception 来捕获所有异常。 12345678910111213141516public class ExceptionTest4 &#123; public static void main(String[] args) &#123; int num = 0; try &#123; num = getInt(&quot;小王&quot;); &#125; catch (Exception e) &#123; &#125; System.out.println(num); &#125; // 字符串转换为数字 public static int getInt(String str) &#123; return Integer.parseInt(str); &#125;&#125; 抛出异常场景描述：java.lang.IllegalArgumentException 使用： 123456public static int getInt(String str)&#123; if(str == null)&#123; throw new IllegalArgumentException(&quot;姓名不能为空&quot;); &#125; return Integer.parseInt(str);&#125; 运行后你会发现，只需要在你想要抛出异常的地方使用 关键字：throw （由于异常也是类，所以需要new 实例化） 异常的错误显示一般称之为 异常堆栈 ，从堆栈中可以看出出错在哪一行，哪个方法调用的。 RuntimeExceptionIllegalArgumentException 的父类 RuntimeException 和其他的 Exception 不同之处在于其并不需要在方法上约定可能抛出的异常： 1234567891011121314public class ExceptionTest6 &#123; public static void main(String[] args) &#123; int num = getInt(null); System.out.println(num); &#125; public static int getInt(String str)&#123; if(str == null)&#123; throw new Exception(&quot;姓名不能为空&quot;); &#125; return Integer.parseInt(str); &#125;&#125; 1未报告的异常错误java.lang.Exception; 必须对其进行捕获或声明以便抛出 如果在哪个方法里抛出了异常，那么就必须要在方法签名上声明。 12345678910111213141516171819public class ExceptionTest8 &#123; public static void main(String[] args) &#123; int num = 0; try &#123; num = getInt(null); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; System.out.println(num); &#125; public static int getInt(String str) throws Exception &#123; if (str == null) &#123; throw new Exception(&quot;姓名不能为空&quot;); &#125; return Integer.parseInt(str); &#125;&#125; 为了捕获异常信息，还是用了 e.getMessage() 方法来获取异常的字符串信息。 考虑到代码安全性，不建议使用 RuntimeException 异常 因为 它在编译阶段是不做检查的，可能会导致一些不必要的问题在你不经意间产生。 UML 图 1234567package com.youkeda.service;public interface UserService &#123; User login(String userName,String password) throws NullPointerException;&#125; 如果接口定义了异常抛出，那么实现类也需要添加同样的异常抛出。 自定义异常如下图所示，我们在 login 上抛出了 Excpetion，这个实在不清楚属于什么异常，所以创建了一个 ParamNullException。 创建异常类UserService.java: 1public class ParamNullException extends Exception &#123;&#125; UserServiceImpl.java: 123456789101112public User login(String userName, String password) throws ParamNullException &#123; if (userName == null || password == null) &#123; throw new ParamNullException(); &#125; for (User user : USERS) &#123; if (user.getUserName().equals(userName) &amp;&amp; user.getPassword().equals(password)) &#123; return user; &#125; &#125; return null;&#125; 自定义异常类的构造函数: 此时我们想知道具体的哪个对象为 null： 1234567891011121314151617public User login(String userName, String password) throws ParamNullException &#123; if (userName == null) &#123; throw new ParamNullException(&quot;用户名为空&quot;); &#125; if (password == null) &#123; throw new ParamNullException(&quot;密码为空&quot;); &#125; for (User user : USERS) &#123; if (user.getUserName().equals(userName) &amp;&amp; user.getPassword().equals(password)) &#123; return user; &#125; &#125; return null;&#125; 出现如下报错： 123456./src/main/java/com/youkeda/service/impl/UserServiceImpl.java:34: 错误: 无法将类 ParamNullException中的构造器 ParamNullException应用到给定类型; throw new ParamNullException(&quot;密码为空&quot;); ^ 需要: 没有参数 找到: String 原因: 实际参数列表和形式参数列表长度不同 因为调用了： 1throw new ParamNullException(&quot;密码为空&quot;); 在 new 的时候 执行了 自定义报错类的 构造函数，但是没有创建这个方法，所以我们需要新建构造函数，其父类构造函数如下： 123456789public class ParamNullException extends Exception &#123; public ParamNullException() &#123; &#125; public ParamNullException(String msg) &#123; super(msg); &#125;&#125; 同时还需要创建一个空的默认构造函数 12public ParamNullException() &#123;&#125; 如果不创建会出现 new ParamNullException() 执行报错。 Finally由于异常的出现会导致异常发生后的代码不会执行，这会使得某些不管任何情况下都需要被执行的步骤被忽略，从而影响程序健壮性。 此时我们便需要使用到 finally 代码块，与 try 组合使用 1234567891011public void work() throws LeaveEarlyException &#123; try &#123; 开门 工作 8个小时 // 可能会抛出异常 DiseaseException 关门 &#125; catch (DiseaseException e)&#123; throw new LeaveEarlyException(); &#125; finally&#123; 关门 &#125;&#125;","categories":[],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"HTML 学习日志","slug":"HTML","date":"2020-09-27T02:39:20.000Z","updated":"2020-10-12T14:34:31.000Z","comments":true,"path":"2020/09/27/HTML/","link":"","permalink":"https://idzforjh.github.io/2020/09/27/HTML/","excerpt":"基础前端语句，很多程序员并不认为其是一种语言。","text":"基础前端语句，很多程序员并不认为其是一种语言。 HTML完整的 HTML 文档结构 1&lt;!DOCTYPE html&gt; 作用：告知浏览器该页面文件的文档类型，指示web浏览器使用哪个 HTML 版本编写页面 位置： &lt;!DOCTYPE&gt; 申明必须是 HTML 文档的第一行，位于 标签之前 &lt;!DOCTYPE&gt; 声明对大小写不敏感 &lt;!DOCTYPE&gt; 声明没有结束标签 1&lt;html lang = &quot;en&quot;&gt; ... &lt;/html&gt; 此元素可告知浏览器其自身是一个HTML文档。 html 与 html 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。文档的头部由head 标签定义，而主题由body标签定义 .lang 属性（语言属性）：当搜索引擎或者浏览器拿到语言属性后，有可能做一些正对指定语言的辅助操作，‘en’ 表示英文。 1&lt;!-- XXX --&gt; 注释 语法 MDNhttps://developer.mozilla.org/zh-CN/docs/Web/HTML 块状和内联标签12345678910&lt;p&gt; Unrivalled luxury, stunning white-sand beaches and an amazing underwater world make Maldives an obvious choice for a true holiday of a lifetime.&lt;/p&gt;&lt;p&gt; &lt;img src=&quot;https://document.youkeda.com/P3-1-HTML-CSS/1.3/1-3-island-2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; 图片标签 img: src 属性是必须的，它包含了你想嵌入的图片的文件路径。 alt 属性包含一条对图像的文本描述，这不是强制性的，但对可访问性而言，它难以置信地有用——屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示alt 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。 显示效果： img 标签是内联标签，而 p 是块状标签 常用文本标签段落标签 p **内联标签 ** strong 1&lt;p&gt;一句话中的&lt;strong&gt;重点内容&lt;/strong&gt;&lt;/p&gt; 对部分字段进行加粗 span 效果： 通常表示一个行内短语，使用 span 可以使网页更有条理 与 strong 不同的是，如果没有添加 样式 文件，span 和普通文本不会有区别 图片标签 在 src &#x3D; 中写入图片的 相对路径 或 绝对路径 其中 alt 属性，定义了描述图像的替换文本，如果图像的URL是错误的，该图像不在 支持的格式 列表中，或者如果图像还没有被下载，用户将看到这里的替换文本。 链接标签 a 标签是内联标签，用户点击后 浏览器会跳转到指定的网址 标签内部不止可以放置文字，也可以放置其他元素，比如 段落、图像、多媒体 等 链接标签的属性href href 属性给出链接指向的网址。它的值应该是一个URL或 锚点 title title 属性 给出链接的说明信息。鼠标悬停在链接上方时，浏览器会将这个属性的值，以提示的形式显示出来。 target target 属性指定如何展示打开的链接。 target属性的值也可以是以下四个关键字： 1_self / _blank / _parent / _top _self 表示在当前页面打开，target 默认是 self _blank 表示在新页面打开 From 表单标签块元素 from 同属于一个表单的表单控件要包含在一个 元素里 1234&lt;!-- &lt;form&gt;是块状标签，要注意：&lt;form&gt;标签不能嵌套&lt;form&gt;标签 --&gt;&lt;form action=&quot;&quot;&gt; &lt;!-- 这里会有一些表单控件 --&gt;&lt;/form&gt; 标签属性： action ： 一个处理此表单信息的程序所在的URL，所述表格信息将在表单提交时被发送到定义的地址； method ： 它的值可以是 Get 或者 Post， 用来规定如何发送表单信息 文本输入框 inpute1234&lt;!-- action=&quot;&quot;则表单信息将提交到当前页面 --&gt;&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; /&gt;&lt;/form&gt; placeholder 站位文本：通常用来 提示 用户需要输入什么，可以通过标签属性“placeholder”来实现 1&lt;input type=&quot;text&quot; placeholder=&quot;昵称&quot; /&gt; name 输入框名字：为了区别于其他的 input ，我们需要给昵称输入框上添加标签属性 name, 作为 input 的名字，在提交表单数据的时候就不会和其他的 input 搞混了 1&lt;input type=&quot;text&quot; placeholder=&quot;昵称&quot; name=&quot;nick&quot; /&gt; value 输入框的值：如果希望子啊输入框中 预填写 数据则使用 value属性。 1&lt;input type=&quot;text&quot; placeholder=&quot;昵称&quot; name=&quot;nick&quot; value=&quot;小明&quot; /&gt; readonly 和 disabled 不可修改输入框在一些特殊情况中，我们会给用户分配固定的数据，但是不希望用户自行更改。 1&lt;input type=&quot;text&quot; placeholder=&quot;昵称&quot; name=&quot;nick&quot; value=&quot;小明&quot; readonly /&gt; 将输入框变成 只读 输入框 除了 readonly 还可以使用 disabled 属性，也是无法让用户更改输入框内容 1&lt;input type=&quot;text&quot; placeholder=&quot;昵称&quot; name=&quot;nick&quot; value=&quot;小明&quot; disabled /&gt; 属性 disabled readonly 对象 所有表单元素 input 和 textarea 作用 使文本框不能输入，当表单以Post 或 Get 的方式提交时，使用了disabled 的元素的值不会被传递出去 仅使文本框不能输入 外观* 是文本框变灰 外观没有变化 多行文本输入框和密码输入框textarea 多行输入框当多行文本输入框中输入的内容超过一行的长度时，它会自动换行，而单行文本输入框则不会换行。 1234567&lt;!-- name属性表示表单元素的名称，placeholder属性表示表单元素的占位文本 --&gt;&lt;textarea name=&quot;sign&quot; rows=&quot;5&quot; cols=&quot;30&quot; placeholder=&quot;请输入个性签名&quot;&gt;&lt;/textarea&gt; 其中 rows 和 cols 分别表示行数（高度）和文本域的可视宽度 密码输入框密码输入框和一般输入框的区别在于，用户输入会以 黑圆点 的形式显示 12&lt;!-- type属性表示表单元素的类型，name属性表示表单元素的名称，placeholder属性表示表单元素的占位文本 --&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot; /&gt; 单选框和复选框单选框 type &#x3D; “radio”属于同一个“单选项”的每个单选按钮，应该拥有相同的name 属性值。 123&lt;!-- type属性表示表单元素的类型，name属性表示表单元素的名称，value属性表示表单元素的值 --&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; /&gt;女 在 input 后直接添加内容 显示 选项内容 优化： 配合 label 标签，点击文字也可以选中选项。 12&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; /&gt;男 &lt;/label&gt;&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; /&gt;女 &lt;/label&gt; 另一种写法： 在 input 标签中添加一个 id属性，同时也给 label 标签也添加了一个属性 for 。这样两者便产生了关系。 1234&lt;input id=&quot;male&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; /&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;&lt;input id=&quot;female&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; /&gt;&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; 多选项框 type&#x3D;”checkbox”12&lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;coding&quot; /&gt;编程 &lt;/label&gt;&lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;other&quot; /&gt;其他 &lt;/label&gt; 属于同一给多选的每一个复选框元素，应该拥有相同的 name属性值 选项菜单每个选项使用 option 标签表示，一组选项用 select 包裹。 1234567&lt;select name=&quot;career&quot;&gt; &lt;option value=&quot;default&quot;&gt;请选择职业&lt;/option&gt; &lt;option value=&quot;staff&quot;&gt;公司职员&lt;/option&gt; &lt;option value=&quot;freelancer&quot;&gt;自由职业者&lt;/option&gt; &lt;option value=&quot;student&quot;&gt;学生&lt;/option&gt; &lt;option value=&quot;other&quot;&gt;其他&lt;/option&gt;&lt;/select&gt; 需要注意的是，这是个单选菜单，如果选择了“学生”，那么提交的数据将会是 career:”student” 提交的内容并不是“学生”，而是 option 标签中的 value 属性，所以每个option 的 value 值要不同。 多选菜单使用 select 标签添加 multiple 属性，就可以使用Ctrl 来单击选项选中多个选项。 1234567&lt;select name=&quot;career&quot; multiple&gt; &lt;option value=&quot;default&quot;&gt;请选择职业&lt;/option&gt; &lt;option value=&quot;staff&quot;&gt;公司职员&lt;/option&gt; &lt;option value=&quot;freelancer&quot;&gt;自由职业者&lt;/option&gt; &lt;option value=&quot;student&quot;&gt;学生&lt;/option&gt; &lt;option value=&quot;other&quot;&gt;其他&lt;/option&gt;&lt;/select&gt; 按钮button 标签： 1&lt;button&gt;注册&lt;/button&gt; 按钮在form中会在点击的时候提交表单数据，但是在button提交表单数据这一点上有的浏览器存在兼容问题，一般还需要加上 type &#x3D; “submit” 来确保数据提交。 1&lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt; 完整注册表单：1234567891011121314151617181920212223242526&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;请输入昵称&quot; /&gt; &lt;textarea name=&quot;sign&quot; rows=&quot;5&quot; cols=&quot;30&quot; placeholder=&quot;请输入个性签名&quot; &gt;&lt;/textarea&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; /&gt;男 &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; /&gt;女 &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;coding&quot; /&gt;编程 &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;other&quot; /&gt;其他 &lt;/label&gt; &lt;select name=&quot;career&quot;&gt; &lt;option value=&quot;default&quot;&gt;请选择职业&lt;/option&gt; &lt;option value=&quot;staff&quot;&gt;公司职员&lt;/option&gt; &lt;option value=&quot;freelancer&quot;&gt;自由职业者&lt;/option&gt; &lt;option value=&quot;student&quot;&gt;学生&lt;/option&gt; &lt;option value=&quot;other&quot;&gt;其他&lt;/option&gt; &lt;/select&gt; &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;&lt;/form&gt; 小结：","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://idzforjh.github.io/tags/HTML/"}]},{"title":"Interface","slug":"Interface","date":"2020-09-25T14:43:23.000Z","updated":"2020-09-25T15:23:37.000Z","comments":true,"path":"2020/09/25/Interface/","link":"","permalink":"https://idzforjh.github.io/2020/09/25/Interface/","excerpt":"Type-C, USB3.1 我只是个中介。","text":"Type-C, USB3.1 我只是个中介。 Interface接口(Interface)技术，主要用来描述类具有什么功能，并不会给出每个功能具体的实现。一个类可以实现（implement）一个或多个接口，并在需要接口的地方，随时使用实现了相对应接口的对象。 接口的语法 基本语法如上图，并不复杂。 12345678/** * 登录接口，支持各种方式的登录 */public interface LoginService &#123; String getLoginPageUrl()&#123; &#125;&#125; 常见错误接口方法定义： 接口抽象方法不能带有主体。 UML 接口定义： 如上图所示，这个图标就是接口(interface)： 图标定义了一个 RoleService，依赖于 Role 类 接口类命名遵循 XxxService , 以 Service 结尾的类名代表其是接口。 接口实现类 语法规则： 接口定义的方法在实现类里必须要全部实现，而且方法签名要一模一样（同样方法名称、方法参数、方法返回值） 由于接口定义的方法都是 public 的，所以实现类的方法控制修饰符也必须是 public。 与继承不同的是： 继承表达的是父子关系，所子类只能继承一个父类； 接口是一个约定，实现类可以拥有多个约定，所以实现类可以实现多个接口只需要用 “,” 分开即可。 实例： 123456package com.youkeda.service;public interface EchoService &#123; // 输出任意的内容 void echo();&#125; 1234567891011121314151617package com.youkeda.service.impl;import com.youkeda.service.RoleService;import com.youkeda.service.EchoService;public class RoleServiceImpl implements RoleService,EchoService&#123; public void addRole(Role role)&#123; &#125; public ArrayList&lt;Role&gt; getRoles()&#123; return null; &#125; public void echo()&#123; &#125;&#125; 接口实例化接口是不能单独实例化的，因为接口只是定义没有具体的实现是不允许实例化的。 以上述例子为例：这条语法是错误的 1EchoService echo = new EchoService(); 正确的实例化是结合实现类的： 123456789101112package com.youkeda.test;import com.youkeda.service.RoleService;import com.youkeda.service.impl.RoleServiceImpl;/** * RoleServiceTest */public class RoleServiceTest &#123; public static void main(String[] args) &#123; RoleService roleService = new RoleServiceImpl(); &#125;&#125; 由于 RoleService 类同时实现了 EchoService，所以实例也可以被转化为 EchoService。 12345678910111213141516171819package com.youkeda.test;import com.youkeda.service.RoleService;import com.youkeda.service.impl.RoleServiceImpl;/** * RoleServiceTest */public class RoleServiceTest &#123; public static void main(String[] args) &#123; RoleService roleService = new RoleServiceImpl(); // 类型转化：把 roleService 实例转化为 EchoService 接口类型 EchoService echoService = (EchoService)roleService; &#125;&#125; UML 接口实现图 RoleServiceImpl 实现了 RoleService 接口 实现类的包名在 service 包下并且命名为 impl，同样 实现类的命名规则是 XxxServicImpl 。 Java 常用接口Map 如上图，Map（映射）是遵循 [key : value] 这样的形式的集合。Key 和 Value 可以是任何 Java 对象。 我们大部分情况下，都会使用 HashMap 这个 Map 实现类，所以如果想得到一个 Map 的实例的话可以使用 HashMap。 12345import java.util.Map;import java.util.HashMap;// key value 得是 Java 类型Map&lt;key,value&gt; map = new HashMap&lt;&gt;(); 举个例子：如果将 1-7 映射为 英文日期，利用 Map： Key Value 1 Monday 2 Tuesday 3 Wednesday 4 Thursday 5 Friday 6 Saturday 7 Sunday 首先使用 map.put(key,value) 这个方法来存储数据。 Map 的键、值都是 String，可以使用 Map&lt;Integer,String&gt; 来表示。（泛型用法） 12345678910// 实例化Map对象Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();map.put(1,&quot;Monday&quot;);map.put(2,&quot;Tuesday&quot;);map.put(3,&quot;Wednesday&quot;);map.put(4,&quot;Thursday&quot;);map.put(5,&quot;Friday&quot;);map.put(6,&quot;Saturday&quot;);map.put(7,&quot;Sunday&quot;); 使用 map.get(key) 获取值 12String weekText = map.get(3);System.out.println(weekText); Map 是一种集合数据： 可以使用 集合大小 size( ) 和 遍历 for 12345for (Map.Entry&lt;Integer,String&gt; entry : map.entrySet())&#123; System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue());&#125; 需要先得到数据格式的集合 entrySet Map 完整接口方法：https://ham.youkeda.com/articles/detail/5f3758fe5e205f30b2c2b2f0 ListList 是 ArrayList 的接口，支持同一类型数据的集合存储。如： 1List&lt;String&gt; strings = new ArrayList&lt;&gt;(); 简化版 for （适用于不关系数组坐标值的场景）： 12345List&lt;String&gt; strings = new ArrayList&lt;&gt;();for(String str : strings)&#123; System.out.println(str);&#125;","categories":[],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Inheritance","slug":"Inheritance","date":"2020-09-25T11:21:44.000Z","updated":"2020-09-25T15:03:05.000Z","comments":true,"path":"2020/09/25/Inheritance/","link":"","permalink":"https://idzforjh.github.io/2020/09/25/Inheritance/","excerpt":"爸爸，儿子，爷爷？！","text":"爸爸，儿子，爷爷？！ Inheritance继承已存在的类就是复用（继承）这些类的方法和域。 继承语法生活案例： 大多数情况下，动物可以拥有名称、年龄这两个属性，所以我们会发现这三个对象的属性相同。当然这三个动物还有很多其他属性，在此只是举例。 当我们遇到这样具备相同的属性以及从属某一类别、领域的对象的时候就可以考虑使用 继承 来解决问题。 在 Java 中继承的语法就是在创建类的时候 多添加一个 extends 关键字 如上述实例中，当使用继承以后。Dog 成为 Animal 的 字类， Animal 称为 父类。 完整代码： Animal.java 123456789101112131415161718192021222324package com.youkeda.model;public class Animal &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Dog.java 1234package com.youkeda.model;public class Dog extends Animal&#123;&#125; Cat.java 1234package com.youkeda.model;public class Cat extends Animal&#123;&#125; Monkey.java 1234package com.youkeda.model;public class Monkey extends Animal&#123;&#125; UML 继承继承关系同样可以使用 UML 来绘制： 箭头指向父类，在继承关系中 private 级别的变量或者方法，字类是获取不到的，字类如果想获取父类的变量和方法可以设置父类的变量和方法为 protected 或者 public 访问控制符。 方法覆盖我们知道每个动物的饮食习惯都不尽相同，如果把这个行为转变为Java对象，就需要每个 对象 各自去实现 “吃” 这个方法，在父子类中，字类如果想要重写父类定义方法的行为称之为：方法覆盖。 比如说，在 Dog 对象中覆盖 eat 方法，并打印出：“狗狗喜欢吃骨头” 123456789package com.youkeda.model;public class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;狗狗喜欢吃肉骨头&quot;); &#125;&#125; 实例化 Dog 对象 123456789public class Test &#123; public static void main(String[] args)&#123; // 实例化 dog 对象 Dog d = new Dog(); d.setName(&quot;小灰&quot;); d.setAge(3); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); &#125;&#125; 实例化 Animal 对象 动物对象是一个抽象的对象，并没有指具体的某个动物，所以一般运用动物对象是要结合子类。 123456789public class Test &#123; public static void main(String[] args)&#123; // 实例化 dog 对象并赋值给 Animal 对象 Animal d = new Dog(); d.setName(&quot;小灰&quot;); d.setAge(3); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); &#125;&#125; 不同： 1Animal d = new Dog(); 父类对象是可以直接成为子类的实例，如果调用 d.eat() 方法代码依旧可以运行。虽然实例化的对象是Dog 子类，但是我们调用父类一样可以执行。同理，虽然调用了父类的 eat() 方法，但是由于 覆盖的原因直接执行子类的 eat() 方法。 注：子类对象兼容父类对象，但是父类对象不能转化为子类。在上述例子中 Dog dog &#x3D; new Animal() 是错误的。 警告：在覆盖一个方法的时候，子类的方法不能低于超类方法的可见性。特别是，如果超类方法是 public，子类的方法一定要声明为 public。经常会发生这种错误：在声明子类方法时候，遗漏了 public 修饰符。此时编辑器将会把它理解为试图提供更严格的访问权限。 Super 关键字通过 this 关键字，可以操作实例内的变量或者方法。 如果想通过子类操作父类也有这样一个关键字：super。（super 只发生在子类中） 123456789101112131415161718192021package com.youkeda.model;public class Animal &#123; private String name; private int age; public void eat()&#123; System.out.println(&quot;动物要饿肚子啦&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 1234567public class Dog extends Animal&#123; public void eat()&#123; // 调用父类的方法 super.eat(); System.out.println(&quot;狗狗喜欢吃肉骨头&quot;); &#125;&#125; 子类运用 super 调用父类一般会发生在父类有一些通用的逻辑可以被执行。 子类的构造函数当父类只有一个参数的构造函数的时候，子类也必须要具备这个构造函数，或者调用 super 方法来实现新的构造函数。 12345678910111213141516171819202122232425public class CustomFile&#123; // 存储文件路径的变量 public String filePath; // 存储文件后缀变量，通过后缀来区分文件类型 public String ext; // 声明一个构造函数，接受文件路径 public CustomFile(String filePath)&#123; //给类变量 filePath 赋值 //this代表的是当前类的实例 this.filePath = filePath; &#125; /** * 获取文件名称 */ public String getName()&#123; // 比如文件路径是 /Users/mac/work/face.png // 把文件路径分隔成数组（分隔符是 / ） // 数组的最后一位就是文件名 String[] paths = filePath.split(&quot;/&quot;); // 数组的最后一位需要减1，因为数组是从索引0开始的。 return paths[paths.length-1]; &#125;&#125; 比如： 1234567public class JavaFile extends CustomFile&#123; // 声明一个构造函数 public JavaFile(String filePath)&#123; super(filePath); &#125;&#125; 如果父类有定义构造函数而子类未定义构造函数： 1234[kind=ERROR, line=1, message=无法将类 CustomFile中的构造器 CustomFile应用到给定类型; 需要: java.lang.String 找到: 没有参数 原因: 实际参数列表和形式参数列表长度不同] 如果需要定义新的构造函数： 12345678910111213public class JavaFile extends CustomFile&#123; private String packageName; // 声明一个构造函数 public JavaFile(String filePath,String packageName)&#123; super(filePath); this.packageName = packageName; &#125; public String getPackageName()&#123; return this.packageName; &#125;&#125; 注意：构造函数里的 super 方法必须在第一行。 如果不在第一行会与没有定义构造函数报错一样。","categories":[],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Introduction to object-oriented.","slug":"Introduction to object-oriented","date":"2020-09-24T12:10:34.000Z","updated":"2020-09-24T13:34:26.000Z","comments":true,"path":"2020/09/24/Introduction to object-oriented/","link":"","permalink":"https://idzforjh.github.io/2020/09/24/Introduction%20to%20object-oriented/","excerpt":"Everything is an object. –Think of Java","text":"Everything is an object. –Think of Java Java 面向对象入门在Java中 对象 其实就是一个 Class（类），在Java世界中所有的程序都是由Class（对象、类）组成的。为了更好的理解对象这件事，有一个专门的图形语言来管理和维护对象，这个语言就是 UML 。 示例： 将上图转换为 Java 代码就是： 1234567891011121314151617181920package com.qq.model;/** * 群对象，封装了群的基础数据 */public class Group&#123; //群唯一的ID String id; //群号 String groupNo; //群图标 String icon; //群名称 String name; //群公告 String notice; //群简介 String desc; // 群成员 ArrayList&lt;User&gt; users;&#125; 类的关联关系对象是对问题领域中事物的抽象。 所谓抽象便是将事物变成编程语言的过程： 大学生信息可以抽象为 Student 对象，在Java中可以创建一个 class Student 大学专业可以抽象为 Major对象，在Java中我们可以创建一个 class Major 对象特性： 万物皆对象。 所有的事物都可以抽象成对象。 每个对象都是唯一的。 世界上不存在一模一样的人，所以在编程时抽象出来的对象也是唯一的。 注：对象的唯一是指类实例化后的每个实例都是唯一的，对于相同事物抽象后的类可以是相同的。 对象具备属性和方法。 每一个对象都拥有自己的属性定义和值，属性+方法 对象便是完整的。 上图中，类Student 通过 Major属性 关联了类 Major。 访问控制修饰符在UML图中如何表示修饰符： 代码化： 1234567package com.qq.model;public class User &#123; private String id; private String name; public void printName()&#123; &#125;&#125; 如果是红色正方形图标（不管图标是否实心），那么说明当前访问控制修饰符是 private 如果是绿色圆形图标（不管图标是否实心），那么说明当前的访问控制修饰符是 public 如果是黄色菱形图标（不管图标是否实心），那么说明当前的访问控制修饰符是 protected 注：颜色不重要，图形才是重要的。不同的 UML 软件颜色会有差异。 封装定义：隐藏对象属性，只能通过公开的方法得到或者设置属性值。业界统一规范：getter、setter 12345678910111213141516public class User&#123; //定义了一个关于名称的实例变量 private String name; /** * 获取 name 的值 */ public String getName()&#123; return this.name; &#125; /** * 设置 name 的值 */ public void setName(String name)&#123; this.name = name; &#125;&#125; get + 属性名称（属性名的首字母要大写），用于获取属性 set + 属性名称（属性名的首字母要大写），用于设置属性 变量作用域Java 类进行实例化后，每一个实例都是唯一的，同样类的成员变量（实例变量）也是唯一的。这个变量的内存空间会随着类实例的创建而被创建，随着类实例的销毁而销毁。 此时我们需要通过 this. 指针来访问类的实例变量： 这里由于 this.name 和参数 name 在不同的作用域所以可以使用相同的名称 除了实例内的作用域外，还有一个作用域是方法内，方法内的对象名称是不能重复的，并且方法内的变量是不能用修饰符的。下例错误代码示范： 1234567891011public void say(String name)&#123; // 这个 private 是错误的 private String msg = &quot;hello&quot;; // 这个 name 变量名是错误的，因为重复了 String name = &quot;a&quot;; int age = 18; // 这个字符串 age 变量名是错误的，因为重复了 String age = &quot;18岁&quot;;&#125; 同理，成员变量名称也是不能重复的 12345public class User&#123; private String name; //这个数字 name 变量名称是错误的，因为重复了 private int name;&#125; UML 封装我们可以继续来看下，如何用 UML 画出一个代表封装的类了： 由于封装格式固定，所以很多时候我们都会省略掉具体的封装方法定义，而采用如下方式： 常量实例变量可以很好的支持面向对象的封装，但是有些时间我们还是需要在多个对象里共享一些数据，这个时候就需要引入 常量 了，常量 也可以成为 静态变量。 语法十分简单，使用 static 关键字就行： 常量应用实例：（存储和调用学校记录） 12345678/** * 学校服务 */ public class SchoolService&#123; // 学校数据的常量 public static ArrayList&lt;School&gt; schools = new ArrayList&lt;&gt;(); &#125; 当我们定义了 静态变量 后，就可以直接操作这个 schools 变量了 1234567891011public class SchoolServiceTest&#123; public static void main(String[] args)&#123; School school = new School(); school.setId(&quot;1&quot;); school.setName(&quot;北京大学&quot;); // 存储数据 SchoolService.schools.add(school); &#125;&#125; 常量的特点之一就是不需要实例化，在Java 中实际上是创建了一个全局唯一的内存空间并且分配给了这个常量。所以常量值只会随着 Java 的销毁而销毁，这样也就方便我们存储数据到内存中，否则数据会随着对象一起被回收。 常量使用常见场景： 常用的字符串值 需要在内存做缓存的值 为了和变量区分开，一般情况下常量的变量名采用全大写字母来定义，单词之间使用 “_” 符号来分割。 常用字符串常量： 123456789/** * 用户Session key */public static final String USER_KEY = &quot;m_key&quot;;/** * 手机验证码 key */public static final String SMS_KEY = &quot;m_sms_key&quot;; 关键字 final 代表这个变量不可以被再次修改，用来保证代码安全。在字符串场景中经常组合使用。 另一个优点：变量值的修改并不会影响代码调用端的修改 12345678910public class UserService&#123; public boolean hasKey(String key)&#123; // 不使用常量的时候 if(key.equals(&quot;m_key&quot;))&#123; return true; &#125; return false; &#125;&#125; 123456789101112131415public class UserService&#123; /** * 用户Session key */ public static final String USER_KEY = &quot;m_key&quot;; public boolean hasKey(String key)&#123; // 使用常量的时候 if(key.equals(USER_KEY))&#123; return true; &#125; return false; &#125;&#125; 稍加思考，如果代码继续写下去我们可能会多次运用到这个 m_key， 但是某一天这个 m_key 变成其他值的时候，是不是每次运用到的地方都需要单独修改？如果此时 是个常量的话就很简单了，只需要修改 USER_KEY 的值就结束了。 内存缓存有些时候为了更高的性能，我们会缓存一些数据到内存中： 123456789101112131415161718192021222324252627282930package com.youkeda.service;import com.youkeda.model.School;/** * 学校服务 */ public class SchoolService&#123; // 学校数据的常量 public static ArrayList&lt;School&gt; SCHOOLS = new ArrayList&lt;&gt;(); // 声明一个静态代码块，用于初始化学校数据 static&#123; School school = new School(); school.setId(&quot;1&quot;); school.setName(&quot;北京大学&quot;); SCHOOLS.add(school); school = new School(); school.setId(&quot;2&quot;); school.setName(&quot;清华大学&quot;); SCHOOLS.add(school); &#125; public static void main(String[] args)&#123; // 测试打印一下内存的数据 for(int i=0;i&lt;SCHOOLS.size();i++)&#123; School school = SCHOOLS.get(i); System.out.println(school.getName()); &#125; &#125;&#125; static 关键词 除了声明静态变量外，还可以声明一个静态代码块（可以在其中执行代码并且调用 static 变量） static 的执行顺序是按照代码行数的顺序来执行的，所以要先声明 static 变量后再创建 static 常量在 UML 图中的声明： Have a nice day!","categories":[],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"Java 字符串基础","slug":"String","date":"2020-09-23T12:39:50.000Z","updated":"2020-09-24T08:15:43.000Z","comments":true,"path":"2020/09/23/String/","link":"","permalink":"https://idzforjh.github.io/2020/09/23/String/","excerpt":"从概念上讲，Java字符串就是 Unicode 字符序列。","text":"从概念上讲，Java字符串就是 Unicode 字符序列。 字符串调用字符串对象方法字符串长度 length字符串长度十分实用，比如我们需要限制字符数量，那么就需要对其进行统计语法如下： 123456public static void main(String[] args) &#123; String message = &quot;今天我在学习 Java 字符串&quot;; // 调用字符串的长度方法得到长度 int size = message.length(); System.out.println(size);&#125; 再对代码进行升级，添加布尔语句。改为判断字符串产长度： 123456789101112public class Test71 &#123; public static void main(String[] args) &#123; boolean countPass = validateCount(&quot;今天天气挺好的&quot;); System.out.println(countPass); &#125; public static boolean validateCount(String message)&#123; if(message.length()&gt;140)&#123; return false; &#125; return true; &#125;&#125; 字符提取 charAt一个字符串，比如说：Hello Java ，我们想取出第二个字，那么就可以使用 charAt(index) 函数，index 就是具体的坐标（与数组一样，从0开始）。 12345678910public static void main(String[] args) &#123; String message = &quot;Hello Java&quot;; // 取出第一个字 char str = message.charAt(0); System.out.println(str); // 取出第二个字 str = message.charAt(1); System.out.println(str);&#125; charAT 方法返回数据类型是 char，只能存储一个字符。 去除左右多余空格 trim在执行 trim() 方法后，会得到一个新的字符串，这个新的字符串左右是没有空格的。 12345678910111213public class Test721 &#123; public static void main(String[] args) &#123; String str = &quot; 优课达 &quot;; // 打印一下现在的length System.out.println(str+&quot;的长度是:&quot;+str.length()); // 处理一下去空格 String newStr = str.trim(); // 打印一下新字符串的length System.out.println(newStr+&quot;的长度是:&quot;+newStr.length()); // 对比再打印一下老的字符串的length System.out.println(str+&quot;的长度是:&quot;+str.length()); &#125;&#125; 注：trim语句会将字符串左右两侧所有的空格都清除。 字符串常用方法查找字符串 indexOf使用 indexOf(“字符串”) 方法来解决匹配特定字符串问题，此方法是接受一个String字符串，当调用这个方法的时候，就会去文本中查找第一个匹配到的坐标索引值。最终得到一个 int 数字类型的数据，如果返回值是 -1 说明不匹配， 如果返回值 ！&#x3D; -1，那么就说明匹配到了。 123456789public static void main(String[] args) &#123;String str = &quot;Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。任职于太阳微系统的詹姆斯·高斯林等人于1990年代初开发Java语言的雏形，最初被命名为Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1990年代互联网的发展，Sun公司看见Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。&quot;; int index = str.indexOf(&quot;Java&quot;); if(index!=-1)&#123; System.out.println(&quot;匹配到了Java，索引位置是&quot;+index); &#125;else&#123; System.out.println(&quot;没有匹配到了Java&quot;); &#125;&#125; 如果需要匹配第二个 “Java” 字段： 1234567public static void main(String[] args) &#123; String str = &quot;Java是一种广泛使用的计算机编程语言，于1995年5月以Java的名称正式发布。&quot;; int index = str.indexOf(&quot;Java&quot;); index = str.indexOf(&quot;Java&quot;, index + 4); System.out.println(&quot;第二次匹配到了Java，索引位置是&quot; + index);&#125; 这里 indexOf 方法有了一个新的调用方式： indexOf(“字符串”,”开始搜索值”) ，第二个参数是一个数字类型，用于设定从什么位置开始寻找目标。 字符串拼接 substringsubstring 方法有两种调用方式： substring(开始索引，结束索引)，这个方法执行的结果就是拼接新的一个字符串从索引开始（含这个值）到索引结束（不包含） substring(开始索引)，这个方法执行的结果就是从开始索引开始（包含这个值）一直到结束。 123456789101112public static void main(String[] args) &#123; String str = &quot;Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。任职于太阳微系统的詹姆斯·高斯林等人于1990年代初开发Java语言的雏形，最初被命名为Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1990年代互联网的发展，Sun公司看见Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。&quot;; int index = str.indexOf(&quot;Java&quot;); if (index != -1) &#123; System.out.println(&quot;匹配到了Java，索引位置是&quot; + index); String newStr = str.substring(index+4); System.out.println(newStr); &#125; else &#123; System.out.println(&quot;没有匹配到了Java&quot;); &#125; &#125; String newStr &#x3D; str.substring(index+4); 这句我们调用的开始索引做了一个+4的计算，因为是取出 “Java” 之后的内容，那么就需要 Java 的索引+其长度。 12// 结束索引应该是 index+4+3String newStr = str.substring(index+4,index+7); 取出 “Java” 字段后三个字符，实例。 字符串开始和结束内容判断 stratsWith &#x2F; endsWith需求示例：判断一个文件格式。 endWith(“字符串”) 方法，接受一个字符串参数，用于判断是否以该字符串结束的，所以返回类型是 boolean(布尔)。 123456public static void main(String[] args) &#123; String fileName = &quot;报告.doc&quot;; if(fileName.endsWith(&quot;.doc&quot;))&#123; System.out.println(&quot;是word文档&quot;); &#125;&#125; 与 endWith 不同的是 stratWith 是用来帕努但文本开头是否是匹配内容。 1234567public static void main(String[] args) &#123; String url = &quot;https://www.youkeda.com&quot;; if(url.startsWith(&quot;https&quot;))&#123; System.out.println(&quot;网址是安全的&quot;); &#125;&#125; 判断URL 字符串替换 replaceAll语法：replaceAll(“要替换的值”,”新值”) 12345678public static void main(String[] args) &#123; String str = &quot;Java&quot;; String newStr = str.replaceAll(&quot;Java&quot;,&quot;Python&quot;); System.out.println(newStr); System.out.println(str); &#125; 除了文本替换外，还有一种作用是作为删除内容，只需要在 “新值” 的位置 换成空格。 去除后缀名： 1234567public static void main(String[] args) &#123; String fileName = &quot;报告.doc&quot;; String name = fileName.replaceAll(&quot;.doc&quot;,&quot;&quot;); System.out.println(name);&#125; 字符串操作字符串分割 split很多时候需要处理有格式的文本数据，比如： 1234姓名|年龄|性别张三|20|男李四|18|男小花|18|女 此时需要使用 split(“分割字符串”) 方法将一个文本变成数组数据。 注意：这个分割字符串可以是字符串也可以是特殊的符号，比如说换行符号(\\n)，split方法执行的结果是返回一个字符串数组对象。 1234567891011public static void main(String[] args)&#123; String text = &quot;姓名|年龄|性别\\n张三|20|男\\n李四|18|男\\n小花|18|女&quot;; // 使用 split 进行换行符的分割，得到一个新的数组对象 String[] data = text.split(&quot;\\n&quot;); // 因为第一行是标题不是数据，所以我们需要把长度-1 // (注意要使用小括号包围，因为要先计算长度再组合字符串) System.out.println(&quot;共有:&quot;+(data.length-1)+&quot; 条记录&quot;);&#125; 我们还可以继续分割每一行数据。 . | * 这三个字符串如果作为分隔开符，那么就要加上 双反斜杠，比如：str.split(“\\|”) 1234567891011121314151617public static void main(String[] args)&#123; String text = &quot;姓名|年龄|性别\\n张三|20|男\\n李四|18|男\\n小花|18|女&quot;; // 使用 split 进行换行符的分割，得到一个新的数组对象 String[] data = text.split(&quot;\\n&quot;); // 因为第一行是标题不是数据，所以我们需要把长度-1 // (注意要使用小括号包围，因为要先计算长度再组合字符串) System.out.println(&quot;共有:&quot;+(data.length-1)+&quot; 条记录&quot;); // 忽略第一行标题数据，所以我们把 i 设为1，从第二条记录开始 for(int i=1;i&lt;data.length;i++)&#123; // 使用 \\\\| 进行字符串分割，得到一个新数组对象 String[] lines = data[i].split(&quot;\\\\|&quot;); System.out.println(&quot;姓名:&quot;+lines[0]+&quot; 年纪:&quot;+lines[1]+&quot; 性别:&quot;+lines[2]); &#125;&#125; 大小写转化 toUpperCase &#x2F; toLowerCase统一格式输出：toUpperCase() 方法。此方法没有参数，作用就是将字符串中的字母全部大写&#x2F;小写，并且返回新的字符串数据。 123456public static void main(String[] args) &#123; String text = &quot;ZhanSan&quot;; // 把拼音全部转化为大写字母 String enName = text.toUpperCase(); System.out.println(enName);&#125; 字符串比较 equals初学者易混淆概念：判断字符串相同并不是使用 &#x3D;&#x3D; 表达式，而是使用 equals(“被比较的字符串”) 123456789101112public static void main(String[] args) &#123; String text = &quot;字符串&quot;; // 使用 equals 方法判断是否相同 if (text.equals(&quot;字符串&quot;)) &#123; System.out.println(&quot;equals 方法字符串相等&quot;); &#125; // 前后顺序无所谓,下面代码是一样的 if (&quot;字符串&quot;.equals(text)) &#123; System.out.println(&quot;equals 方法字符串相等&quot;); &#125;&#125; Java 的 Jvm 编译做过优化，有时 &#x3D;&#x3D; 会成功，但大部分情况下会报错。 数字和字符串转化 integer.parselnt大多数情况下，原始数据都是字符串但我们需要对其进行数学运用。 在Java中，我们可以使用 integer 对象的 parselnt 方法进行处理，这个方法的作用就是让字符串变成数字。 12345678910public static void main(String[] args) &#123; String text = &quot;123&quot;; // 转化字符串为数字 int a = Integer.parseInt(text); System.out.println(a); // 转化字符串为数字 a = Integer.parseInt(&quot;100&quot;); System.out.println(a);&#125; 数字转为字符串有两种方法，一种是 +： 123456public static void main(String[] args) &#123; int a = 100; //使用空字符串相加数字，会自动变成字符串类型 String str = &quot;&quot;+a; System.out.println(str); &#125; 还有一个是使用 String.valueOf() 方法，此方法参数接受数字、浮点、布尔类型转化为字符串。 1234567public static void main(String[] args) &#123; int a = 100; //使用valueOf强制把数字转化为字符串 String str = String.valueOf(a); System.out.println(str);&#125;","categories":[],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]},{"title":"ArrayList","slug":"ArrayList","date":"2020-09-19T11:09:06.000Z","updated":"2020-09-25T12:53:50.000Z","comments":true,"path":"2020/09/19/ArrayList/","link":"","permalink":"https://idzforjh.github.io/2020/09/19/ArrayList/","excerpt":"数组容器 奇怪奇怪真奇怪，奇怪奇怪不奇怪。","text":"数组容器 奇怪奇怪真奇怪，奇怪奇怪不奇怪。 ArrayList 语法ArratList 本质是一个动态数组对象，可以方便存储集合对象，一般来说我们会把同一个类型的数据存储在这个ArrayList里。我们如果要使用ArrayList就必须要先实例化，实例化的语法都是一样的，使用 new 关键字，并且需要指定对象类型。 1234// 这里的 Java 对象类型可以是任意的对象类型// 比如 String、Integer、House 等// 这里的 &lt;&gt; 是 Java 泛型的规范,记住这个语法就行了ArrayList&lt;Java 对象类型&gt; list = new ArrayList&lt;&gt;(); ArrayList 对象是存放在java.util包下的，所以如果需要使用它就需要先进行 import 引入import java.util.ArrayList; add 方法完成ArrayList实例化之后，就可以使用ArrayList的add方法来进行数据的添加。 1234567891011import java.util.ArrayList;public class ArrayListTest1&#123; public static void main(String[] args)&#123; // 创建一个 ArrayList 存储字符串集合 ArrayList&lt;String&gt; strs = new ArrayList&lt;&gt;(); // 添加数据到 ArrayList 实例里 strs.add(&quot;张三&quot;); strs.add(&quot;李四&quot;); &#125;&#125; get&#x2F;size 方法ArrayList 是动态数组也就具备如下特点： 可以获取长度 size() 可以根据索引获取具体的值 get(索引)，ArrayList的索引是从0开始的。 索引 index: 1234567891011// 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。public int indexOf(int ch)//返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。public int indexOf(int ch, int fromIndex)//返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。int indexOf(String str)// 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1int indexOf(String str, int fromIndex) 123456789101112131415161718import java.util.ArrayList;public class ArrayListTest1&#123; public static void main(String[] args)&#123; // 创建一个 ArrayList 存储字符串集合 ArrayList&lt;String&gt; strs = new ArrayList&lt;&gt;(); // 添加数据到 ArrayList 实例里 strs.add(&quot;张三&quot;); strs.add(&quot;李四&quot;); // 获取集合的长度 int size = strs.size(); // 使用 for 循环迭代每一条记录 for(int i=0;i&lt;size;i++)&#123; // 根据索引获取值，值的类型是 String String str = strs.get(i); System.out.println(str); &#125; &#125;&#125; for 语句迭代集合1234567891011121314151617import java.util.ArrayList;public class ArrayListTest1&#123; public static void main(String[] args)&#123; // 创建一个 ArrayList 存储字符串集合 ArrayList&lt;String&gt; strs = new ArrayList&lt;&gt;(); // 添加数据到 ArrayList 实例里 strs.add(&quot;张三&quot;); strs.add(&quot;李四&quot;); // 获取集合的长度 int size = strs.size(); // 使用 for 循环迭代每一条记录 for(String str : strs)&#123; System.out.println(str); &#125; &#125;&#125; 语法： 1for( 集合变量的类型 变量名称 : 集合变量 ) 在上述例子中使用的集合是字符串集合，所以使用的是 1for(String str : strs)&#123; &#125; 与之前的 for i 语句的区别在于，遍历集合的时候能否得到 i 值。","categories":[],"tags":[{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"}]}],"categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/categories/Algorithms/"},{"name":"Network engerning","slug":"Network-engerning","permalink":"https://idzforjh.github.io/categories/Network-engerning/"},{"name":"Linux","slug":"Linux","permalink":"https://idzforjh.github.io/categories/Linux/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://idzforjh.github.io/categories/Machine-Learning/"},{"name":"Web of CTF","slug":"Web-of-CTF","permalink":"https://idzforjh.github.io/categories/Web-of-CTF/"},{"name":"Queen`s Gambit","slug":"Queen-s-Gambit","permalink":"https://idzforjh.github.io/categories/Queen-s-Gambit/"},{"name":"Java基础","slug":"Java基础","permalink":"https://idzforjh.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java Web","slug":"Java-Web","permalink":"https://idzforjh.github.io/categories/Java-Web/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://idzforjh.github.io/tags/Machine-Learning/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://idzforjh.github.io/tags/Algorithms/"},{"name":"Ad-hoc","slug":"Ad-hoc","permalink":"https://idzforjh.github.io/tags/Ad-hoc/"},{"name":"Linux","slug":"Linux","permalink":"https://idzforjh.github.io/tags/Linux/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://idzforjh.github.io/tags/Algorithm/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://idzforjh.github.io/tags/OpenCV/"},{"name":"Kali","slug":"Kali","permalink":"https://idzforjh.github.io/tags/Kali/"},{"name":"Screeps","slug":"Screeps","permalink":"https://idzforjh.github.io/tags/Screeps/"},{"name":"前端","slug":"前端","permalink":"https://idzforjh.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Think of Java","slug":"Think-of-Java","permalink":"https://idzforjh.github.io/tags/Think-of-Java/"},{"name":"CSS 3","slug":"CSS-3","permalink":"https://idzforjh.github.io/tags/CSS-3/"},{"name":"HTML 5","slug":"HTML-5","permalink":"https://idzforjh.github.io/tags/HTML-5/"},{"name":"HTML","slug":"HTML","permalink":"https://idzforjh.github.io/tags/HTML/"}]}